{"meta":{"title":"AfullA","subtitle":"","description":"","author":"AfullA","url":"https://afulla.github.io","root":"/"},"pages":[],"posts":[{"title":"关于测试的一些记录","slug":"关于测试的一些学习记录","date":"2020-07-15T09:40:35.000Z","updated":"2020-08-31T11:00:20.600Z","comments":true,"path":"2020/07/15/关于测试的一些学习记录/","link":"","permalink":"https://afulla.github.io/2020/07/15/%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"测试探讨的方面：业务、测试方法、测试设计、自动化、测试管理、测试流程、测试策略等。 测试策略可以理解成“测什么”和“怎么测”，比如说：测试的对象和范围是什么？测试的目标是什么？测试的重点和难点是什么？测试的深度和广度如何？如何安排测试活动（先测什么再测什么）？如何评价测试的效果等。基于“产品质量目标”，基于“风险”，在充分考虑“产品研发状况”的前提下来安排测试活动，在有限的时间里进行“刚刚好”的测试。 测试活动可以概括为测试需求分析、测试分析和涉及、测试执行和测试质量评估。测试分析不仅能够帮助测试更好地认识产品准备测试，还能反过来帮助开发确认需求，确认产品在非功能性属性（如性能、可靠性、易用性等）方面的设计。测试的意义，不仅在于测试发现bug，为产品发布提供信心，还在于缺陷预防，切实提升产品质量。 测试需求分析阶段 理解需求 制定一份总体测试策略，明确测试范围、测试目标、测试重点和难点、测试深度和广度以及如何安排测试活动。 测试重点是由产品价值、质量目标、产品实现（新写代码、开源代码或是继承代码）和历史测试情况（主要针对继承产品）等多项因素综合决定的。测试难点是从测试技术角度来说的，是对产品测试验证难易程度的分析。测试广度是从覆盖的角度来描述，测试深度是从测试方法来描述。 ​ 多理解产品的商业目标，梳理用户使用场景（梳理的用户场景可变为测试场景）。 ​ 测试分层是指将一些具有相同测试目标的测试活动放在一起作为一个测试的层次。 测试执行阶段 制定版本测试策略 测试范围和计划相比的偏差；本版本的测试目标；需要重点关注的内容；测试用例的选择；测试执行顺序；试探性的测试策略；接收测试策略；回归测试策略；探索测试策略；自动化测试策略 跟踪测试执行 跟踪测试用例执行的情况；每日缺陷跟踪；调整测试策略 版本质量评估 版本质量评估是对每个测试版本的质量总结，一个“特性版本的质量档案”样例： 测试质量评估阶段 和版本质量评估不同，此时的质量评估是指阶段质量评估或者发布时的质量评估，需要给出“能否进入下一阶段的测试”或者“发布”的结论。需要重点关注的内容包括：确认总体测试策略中重要的质量目标是否达到；对总体测试策略中未达标的一般性的质量目标，确定应对措施；进行遗留缺陷分析。需要特别注意此时的缺陷修复策略和对非必现bug的处理。 软件产品质量六属性 功能性：软件产品在指定条件下使用时，提供满足明确和隐含要求的功能的能力 可靠性：在指定条件下使用时，软件产品维持规定的性能级别的能力 设备最好不要出故障；设备出现故障了不要影响主要的功能和业务；如果影响了主要功能和业务，系统可以尽快定位并恢复 易用性：软件产品质量属性中的易用性是指用户在指定条件下使用软件产品时，产品被用户理解、学习、使用和吸引用户的能力 效率：软件产品质量属性中的效率是指在规定的条件下，相对于所用资源的数量，软件产品可提供适当的性能的能力。通常效率就是我们常说的产品性能 可维护性：软件产品质量属性中的可维护性是指软件产品可被修改的能力。这里的修改是指纠正、改进软件产品，和软件产品对环境、功能规格变化的适应性 可测试性关注的是软件的修改是否正确、是否符合预期 可移植性：软件产品质量属性中的可移植性是指软件产品从一种环境迁移到另一种环境的能力。这里的环境可以理解为硬件、软件或组织等不同的环境 从哪些方面（测试类型）用哪些方法（测试方法）去测试产品（质量属性） （1）如何保证测试验证的“全面性”；（2）如何确定测试“深度”。根据产品的质量目标、产品的风险分析来确定测试的重点和难点、深度和广度。 可靠性测试测试的是产品在各种条件下维持规定的性能级别的能力：异常值输入法、故障植入法、稳定性测试法、压力测试法、恢复测试法 异常值输入法：一种使用系统不允许用户输入的数值作为测试输入的可靠性测试方法，可以测试到系统的容错性，可以测试到系统处理各种错误输入的能力 故障植入法：把系统放在有问题的环境中进行测试，可测试到系统的容错性和成熟性。可以从以下几个方面来分析，进行故障植入：（1）用户的业务环境中，会有哪些故障、错误或问题，例如断网、网络延迟、数据丢包等；（2）如果系统被部署在用户的硬件环境中，考虑系统所需的硬件资源，例如CPU、内存、存储空间等；（3）如果系统被安装在用户的系统中，考虑系统存在软件冲突、驱动不正确等情况；（4）如果系统是一个独立的设备，考虑它的关键器件，如机框、单板、芯片等出现问题时，系统的反应是否合理 稳定性测试法：在一段时间里，长时间大容量运行某业务的一种可靠性测试法，它能够非常有效地测试到系统的“成熟性” 稳定性测试是在低于性能值的前提下测试的。事实上，用户在使用系统时，也不会时刻让系统在极限状态运行，在测试时，可以控制测试中的负载量，使其和用户的实际情况尽量接近，使得测试更准确和有价值 压力测试是在高于性能值的前提下进行测试的。虽然测试时负载超过了系统能够处理的最大能力，但并不等于这种情况下系统的功能都会失效，需要根据实际情况来分析系统的表现是否合理，例如系统最多支持100个用户并发登录，当有110个用户同时发起登录时应保证有100个用户可以正常登录 稳定性测试：多、并、复、异。多：在测试中增加用户对功能的操作数量，测试系统的稳定性；并：在测试中让多个用户同时操作某个功能，也可称为并发测试；复：在测试中反复让一个或多个用户反复进行新建、刷新、删除、同步、备份之类的操作，能够有效地发现系统在资源申请和释放上是否存在问题；异：在测试中让一个或多个用户反复进行异常操作，验证系统是否能够持续作出合理的反应","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://afulla.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"关于Selenium","slug":"关于Selenium","date":"2020-05-11T03:32:52.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2020/05/11/关于Selenium/","link":"","permalink":"https://afulla.github.io/2020/05/11/%E5%85%B3%E4%BA%8ESelenium/","excerpt":"Selenium特点： 开源、免费 多浏览器支持 多平台支持 多语言支持 对web页面有良好的支持 简单、灵活 支持分布式测试用例执行","text":"Selenium特点： 开源、免费 多浏览器支持 多平台支持 多语言支持 对web页面有良好的支持 简单、灵活 支持分布式测试用例执行 Selenium IDE是嵌入到Firefox浏览器中的一个插件，实现简单的浏览器操作的录制与回放功能。它能快速地创建bug重现脚本，在测试人员的测试过程中，发现了bug之后可以通过IDE将重现的步骤录制下来，以帮助开发人员更容易的重现bug。 Selenium Grid是一种自动化的测试辅助工具，利用Grid可以很方便地同时在多台机器上和异构环境中并行运行多个测试事例，其特点是：并行执行、通过一个主机统一控制用例在不同环境不同浏览器下运行、灵活添加变动测试机。 Selenium RC是Selenium核心工具。Selenium RC支持多种不同的语言编写自动化脚本，通过Selenium RC的服务器作为代理服务器去访问应用从而达到测试的目的。 Selenium RC使用分Client Libraries和Selenium Server，Client Libraries库主要用于编写测试脚本，用来控制Selenium Server的库。 Selenium Server负责控制浏览器行为，总的来说，Selenium Server主要包括3个部分：Launcher、HttpProxy、Core。其中Selenium Core是被Selenium Server嵌入到浏览器页面中的。其实Selenium Core就是一堆JS函数的集合，就是通过这些JS函数，我们才可以实现应用程序对浏览器的控制操作。Launcher用于启动浏览器，把Selenium Core加载到浏览页面中，并把浏览器的代理设置为Selenium Server的Http Proxy。 Selenium2.0加入WebDriver，是Selenium RC的替代品。Selenium RC和WebDriver的区别：Selenium RC在浏览器中运行JavaScript应用，使用浏览器内置的JavaScript翻译器来翻译和执行Selenium命令。WebDriver通过原生浏览器支持或者浏览器扩展直接控制浏览器。WebDriver针对各个浏览器而开发，取代了嵌入到被测web应用中的JavaScript。与浏览器的紧密集成支持创建更高级的测试，避免了JavaScript安全模型导致的限制。 WebDriver是按照server-client的经典设计模式设计的。server端就是remote server，可以是任意浏览器。当我们脚本启动浏览器后，该浏览器就是remote server，它的职责就是等待client发送请求并作出响应。client端简单说来就是我们的测试代码，我们测试代码中的一些行为，比如打开浏览器，转跳到特定的url等操作是以http请求的方式发送给被测浏览器，也就是remote server，remote server接受请求，并执行相应操作，并在response中返回执行状态等信息。 webdriver工作流程： 1.WebDriver启动目标浏览器，并绑定到指定端口。该启动的浏览器实例，作为WebDriver的remote server 2.Client端通过CommandExecuter发送HTTPRequest给remote server的侦听端口（通信协议：the webdriver wire protocol） 3.remote server需要依赖原生的浏览器组件（如IEDriverServer.exe、chromedriver.exe）来转化浏览器的native调用 启动debug，可以看到交互信息 1logging.basicConfig(level=logging.DEBUG) WebDriver Cheat Sheet driver初始化 基本：driver=webdriver.Firefox()driver=webdirver.Chrome()driver=webdriver.Ie高级：#FirefoxProfile profile=webdriver.FirefoxProfile()profile.set_preference(….)driver = webdriver.Firefox(firefox_profile=profile)#ChromeOptionsoptions = webdriver.ChromeOptions()options.add_experimental_option()driver=webdriver.Chrome(executable_path=’’,chrome_options=options)http://blog.csdn.net/vinson0526/article/details/51850929http://blog.csdn.net/zwq912318834/article/details/78933910 定位 单个元素：driver.find_element_by_多个元素：driver.find_elements_by_idnameclass_nametag_namelink_textpartial_link_textcss_selectorxpath 导航 driver.get()driver.refresh()driver.forward()driver.back() 操作 element = driver.find_element_by..element.click()element.send_keys()element.submit()element.clear()element.textelement.get_attribute()element.is_displayed()element.is_enable()element.is_selected()select = Select(element)select.select_by_index() index从0开始select.select_by_value()select.select_by_visible_text()select.optionsselect.all_selected_optionsselect.first_selected_optiondriver.maximize_window()driver.get_cookies()driver.delete_all_cookies()driver.get_cookie(‘cookie name’)driver.delete_coolie(‘cookie name’)driver.add_cookie(cookie_dict)driver.switch_to.active_element #获取当前焦点元素 window current_handle =driver.current_window_handleall_handles = driver.window_handlesdirver.switch_to.window() Alert driver.switch_to.alert.text 弹窗文本driver.switch_to.alert.accept() 确定按钮driver.switch_to.alert.dismiss() 取消按钮driver.switch_to.alert.send_keys() 往prompt型alert中传入字符串 selenium grid ava -jar selenium-server-standalone-2.39.0.jar -role hubjava -jar selenium-server-standalone-2.39.0.jar -role node -port 5555 Selenium三种等待方式 1.强制等待：sleep2.隐式等待：implicitly_wait隐式等待设置了一个最长等待时间，如果在规定的时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。但是有个弊端，那就是程序会一直等待整个页面加载完成，但有时候页面想要的元素早就加载完成了3.显示等待：配合该类的until()和until_not()方法，简单来说就是程序每隔一段时间检查一下，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长等待时间 123456789from selenium import webdriverfrom selenium.webdriver.commom.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Firfox()driver.get(\"http:www.baidu.com\")element = WebDriverWait(driver, 5, 0.5).until(EC.presence_of_element_located((By.ID, \"kw\")))element.send_keys('selenium') WebDriverWait()是由webdriver提供的等待方法(显示等待）。在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，如果超过设置时间检测不到则抛出异常。一般由until()(或until())方法配合使用。 title_is 用于判断标题是否 xx title_contains 用于判断标题是否包含 xx 信息 presence_of_element_located 元素是否存在 visibility_of_element_located 元素是否存在 visibility_of 是否可见 presence_of_all_elements_located 判断一组元素的是否存在 text_to_be_present_in_element 判断元素是否有 xx 文本信息 text_to_be_present_in_element_value 判断元素值是否有 xx 文本信息 frame_to_be_available_and_switch_to_it 表单是否可用，并切换到该表单 invisibility_of_element_located 判断元素是否隐藏 element_to_be_clickable 判断元素是否点击，它处于可见和启动状态 element_to_be_selected 被选中的元素 element_located_selection_state_to_be 期望找到一个元素并检查是否选择状态 alert_is_present 预期一个警告信息 staleness_of 判断一个元素是否仍在DOM中，传入WebElement对象，可以判断页面是否刷新了 webdriver提供了implicitly_wait()方法来实现隐式等待 1driver.implicitly_wait(10) # 10s switch_to.frame() 1234driver.switch_to.frame(0) # 1.用frame的index来定位，第一个是0 driver.switch_to.frame(\"frame1\") # 2.用id来定位 driver.switch_to.frame(\"myframe\") # 3.用name来定位 driver.switch_to.frame(driver.find_element_by_tag_name(\"iframe\")) # 4.用WebElement对象来定位 switch_to_default_cotent()方法返回上一层表单 driver.current_window_handle获得当前窗口句柄 driver.window_handles获得所有打开窗口句柄 driver.execute_script()调用JavaScript driver.get_screenshot_as_file()窗口截图 driver.add_cookie()设置cookie","categories":[],"tags":[{"name":"Selenium","slug":"Selenium","permalink":"https://afulla.github.io/tags/Selenium/"}]},{"title":"测试日常记录","slug":"测试日常记录","date":"2020-03-28T07:07:47.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2020/03/28/测试日常记录/","link":"","permalink":"https://afulla.github.io/2020/03/28/%E6%B5%8B%E8%AF%95%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","excerpt":"针对以下程序编写用例 这个程序从一个输入对话框中读取三个整数值，这三个整数值代表了三角形三条边的长度。程序显示提示信息，指出该三角形是何种三角形：不规则三角形、等腰三角形、等边三角形 输入值用例角度： 1.是否有这样的测试用例，代表了 一个有效的不规则三角形 2.是否有这样的测试用例，代表一个有效的等边三角形 3.是否有这样的测试用例，代表一个有效的等腰三角形 4.是否至少有三个这样的测试用例，代表有效的等腰三角形，从而可以测试到两等边的所有三种情况（3，3，4；3，4，3；4，3，3） 5.是否有这样的测试用例，某变长等于0 6.是否有这样的测试用例，某变长等于负数 7.是否有这样的测试用例，三个整数皆大于0，其中两边长的和等于第三边？（如果程序判断1，2，3是一个有效的不规则三角形，则说明程序存在缺陷） 8.是否至少有三个第7类用例，列举一边等于另两边之和的所有情况 9.是否有这样的测试用例，三个整数皆大于0，其中两边之和小于第三边 10.是否至少有三个第9类测试用例，列举了一边大于另外两边的全部可能情况 11.是否有这样的测试用例，三边长皆为0 12.是否有这样的测试用例，输入的边长为非整数值 13.是否有这样的测试用例，输入的边长个数不对 用于代码检查的错误列表","text":"针对以下程序编写用例 这个程序从一个输入对话框中读取三个整数值，这三个整数值代表了三角形三条边的长度。程序显示提示信息，指出该三角形是何种三角形：不规则三角形、等腰三角形、等边三角形 输入值用例角度： 1.是否有这样的测试用例，代表了 一个有效的不规则三角形 2.是否有这样的测试用例，代表一个有效的等边三角形 3.是否有这样的测试用例，代表一个有效的等腰三角形 4.是否至少有三个这样的测试用例，代表有效的等腰三角形，从而可以测试到两等边的所有三种情况（3，3，4；3，4，3；4，3，3） 5.是否有这样的测试用例，某变长等于0 6.是否有这样的测试用例，某变长等于负数 7.是否有这样的测试用例，三个整数皆大于0，其中两边长的和等于第三边？（如果程序判断1，2，3是一个有效的不规则三角形，则说明程序存在缺陷） 8.是否至少有三个第7类用例，列举一边等于另两边之和的所有情况 9.是否有这样的测试用例，三个整数皆大于0，其中两边之和小于第三边 10.是否至少有三个第9类测试用例，列举了一边大于另外两边的全部可能情况 11.是否有这样的测试用例，三边长皆为0 12.是否有这样的测试用例，输入的边长为非整数值 13.是否有这样的测试用例，输入的边长个数不对 用于代码检查的错误列表 1.数据引用错误 是否有引用的变量未赋值或未初始化 对于所有的数组引用，是否每一个下标的值都在相应维规定的界限之内 对于所有的数组引用，是够每一个下标的值都是整数 对于所有通过指针或引用变量的引用，当前引用的内存单元是否分配 如果一个内存区域具有不同属性的别名，当通过别名进行引用时，内存区域中的数据值是否具有正确的属性 变量值的类型或属性是否与编译器所预期的一致 在使用的计算机上，当内存分配的单元小于内存可寻址的单元大小时，是否存在直接或间接的寻址错误 当使用指针或引用变量时，被引用的内存属性是否与编译器所预期的一致 …… 2.数据声明错误 是否所有的变量都进行了明确的声明 如果变量所有的属性在声明中没有明确说明，那么默认的属性能否被正确理解 如果变量在声明语句中被初始化，那么它的初始化是否正确 是否每个变量都被赋予了正确的长度和数据类型 变量的初始化是否与其存储空间的类型一致 是否存在着相似名称的变量 …… 3.运算错误 是否存在不一致的数据类型间的运算 是否有混合模式的运算，例如将浮点变量与一个整型变量做加法运算 是否有相同的数据类型，不同字长变量间的运算 赋值语句的目标变量的数据类型是否小于右边表达式的数据类型或结果 在表达式的运算中是否存在表达式向上或向下溢出的情况 除法运算中的除数是否可能为0 …… 4.比较错误 是否有不同数据类型之间的比较运算 是否有混合模式的比较运算，或不同长度的变量间的比较运算 比较运算是否正确 每个布尔表达式所叙述的内容是否都正确 布尔运算符的操作数是否是布尔类型的 …… 5.控制流程错误 是否所有循环都终止了 由于实际情况没有满足循环的入口条件，循环体是否有可能从未执行过 循环越界 是否存在“仅差一个”的错误，如迭代数量恰恰多一次或少一次，这在从0开始的循环中是常见的错误，我们会经常忘记将“0”作为一次计数 …… 6.接口错误 被调用模块接收到的形参数量是否等于调用模块发送的实参数量 实参的属性是否与相应的形参属性相匹配 此模块传递给彼模块的实参数量，是否等于彼模块期望的形参数量 …… 7.输入输出错误 是否有足够的可用内存空间来保留程序将读取的文件 是够所有文件使用之后都关闭了 …… 用例设计 黑盒测试：等价类划分、边界值分析、因果图分析、错误猜测 白盒测试：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、多重条件覆盖 白盒测试关注的是测试用例执行的程度或覆盖程序逻辑结构的程度。 边界值分析方法和等价划分之间的重要区别是，边界值分析考察正处于等价划分边界或在边界附近的状态。 系统测试测试用例设计建议：能力测试（确保程序的目标功能实现）、容量测试（发现处理大容量数据时的程序异常）、强度测试（发现大规模负载、高强度不间断持续的数据处理中的异常）、可用性测试（评估最终用户在使用软件并与软件交互时的可用性问题）、安全性测试、性能测试（评估程序的响应时间以及吞吐量瓶颈）、存储测试（确保程序可以正确处理其对存储的需求，包括系统的存储和物理上的存储）、配置测试、兼容测试、安装测试、可靠性测试、可恢复性测试、可维护测试（评估系统是否拥有良好的数据处理和日志机制，以备技术支持和调试之需）、文档测试 一个良好的测试计划应包括： 目标：必须定义每个测试阶段的目标 结束准则：必须制定准则以规定每个测试阶段何时可以结束 进度：每个阶段都须有时间表，应指出何时设计、编写和执行测试用例 责任：对于每一个阶段，应当确定谁来设计、编写和验证测试用例，谁来修改发现的软件错误 测试用例库及标准：在大型项目中，用于确定、编写及存储测试用例的系统方法是必须的 工具：必须确定需要使用的测试工具 计算机时间：计划每个测试阶段所需的计算机时间，包括用来编译应用程序的服务器、用来进行安装测试所需的桌面计算机等 硬件配置 集成：测试计划的一部分是定义程序如何组装在一起的方法（例如自底向上的增量测试） 跟踪步骤：必须跟踪测试进行中的方方面面，包括对错误易发模块的定位，以及有关进度、资源和结束准则的进展估计 调试步骤：必须制定上报已发现错误、跟踪错误修改进程以及将修改部分加入系统中去的机制 回归测试：回归测试在对程序作了功能改进或进行了修改之后进行，其目的是判断程序的改动是否引起了程序的其他方面的退步。回归测试通常重新执行测试用例中的某子集 归纳法调试 1.确定相关数据：列举出所有知道的程序执行正确和不正确之处，这些不正确之处即是症状 2.组织数据：归纳意味着从特殊到一般，组织相关数据，以便观察线索间的模式，尤其重要的是找到矛盾、事件。组织线索的一种方法（“是”和“否”列，它们所描述的矛盾之处最终可能会导致对错误的假设）： ？ 是 否 是什么（总体的症状） 在何处（症状出现的地方） 何时 多大程度（这些症状的范围和重要性） 3.作出假设：研究线索之间的联系，利用线索结构里可能的模式作出一个或多个关于错误原因的假设 4.证明假设 5.解决问题 演绎法调试 演绎的过程是从一些普遍的理论或前提出发，使用排除和精炼的过程，达到一个结论 1.列举出所有可能的原因或假设 2.利用数据排除可能的原因 3.提炼剩下的假设 4.证明剩下的假设 5.修复问题 互联网应用系统被视为三层的C/S程序：表示层、业务逻辑层、数据访问层 每一层的测试内容参考： 测试内容 注解 可用性/人机界面 检查整体的外观和感觉字体、图形和色彩所有用户输入要予以确认，由此可以明明白白让用户知道输入的数据有没有被接收 性能 检查快速载入页面检查快捷的事务较差的性能往往造成不好的印象 业务规则 检查对业务流程的描述是否准确考虑目标用户群的业务环境确保术语和风格遵循行业规则 事务准确性 确保事务正确完成确保被取消的事务回滚正确对用户输入进行验证是否能满足安全性和准确性需求 数据有效性和完整性 检查电话号码、电子邮件地址和金额数量的格式是否正确确保字符集适当 系统可靠性 网络结构 移动应用测试分类 测试分类 说明 安装/卸载 确保用户可以正确地安装应用程序确保用户可以完全卸载应用程序 网络基础设施 证实应用程序在网络丢失的情况能够正确响应证实应用程序能够正确响应网络回复的情况证实应用程序能够在网络信号差的情况下正确响应 来电和短信处理 测试用户能否在应用程序运行的情况下接电话以及回短信测试用户处理完来电和短信之后能否返回应用程序测试用户能否在不中断应用的情况下取消来电和短信 内存 确保应用程序在内存不足的情况下仍能稳定工作 按键 按键按产品规格说明书实现 退出 能够正常退出 充电 充电模式时正常工作 电量 电量不足时表现，多长时间会耗尽电量 硬件资源 不过度占用cpu，不过度消耗内存资源 冒烟测试：是指在对一个新版本进行大规模测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。引入到软件测试中，就是指测试小组在正规测试之前，先投入较少的人力和时间验证一个软件的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的时间成本和人力成本。 回归测试：回归测试是指修改了旧代码后，重新进行测试以确认修改后没有引入新的错误或导致其他代码产生错误。 随机测试：是指测试中所有的输入数据都是随机的，其目的是模拟用户的真实操作，并发现一些边缘性的错。 探索性测试：探索性测试可以说是一种测试思维技术，探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://afulla.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"数据结构学习记录","slug":"数据结构学习记录","date":"2020-03-12T02:31:44.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2020/03/12/数据结构学习记录/","link":"","permalink":"https://afulla.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"数组与链表 数组和链表是线性表的两种存储方式 数组，所有元素都连续存储在一段内存中，且每个元素占用的内存大小相同，这使得数组具备了通过下标快速访问数据的能力。但连续存储的缺点也很明显，增加容量、增删元素的成本很高，时间复杂度均为O(n)。增加数组容量需要先申请一块新的内存，然后复制原有的元素。删除元素时需要移动被删除元素之后的所有元素以保证元素是连续的。 链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存放下一个节点的指针。由于不用按顺序存储，链表在插入的时候可以达到O(1)的复杂程度，但是查找一个节点或者访问特定编号的节点则需要O(N)的时间。 使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销更大。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://afulla.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Python日常记录","slug":"Python日常记录","date":"2020-02-25T09:30:39.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2020/02/25/Python日常记录/","link":"","permalink":"https://afulla.github.io/2020/02/25/Python%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","excerpt":"Python中的index()、find()方法 1str.index(str, beg=0, end=len(string)) 参数 str – 指定检索的字符串 beg – 开始索引，默认为0。 end – 结束索引，默认为字符串的长度。 返回值 如果包含子字符串返回开始的索引值，否则抛出异常。 1str.find(str, beg=0, end=len(string)) 参数 str – 指定检索的字符串 beg – 开始索引，默认为0。 end – 结束索引，默认为字符串的长度。 返回值 如果包含子字符串返回开始的索引值，否则返回-1。 find不能用于list Pthon中的list.sort()、sorted()方法 Python 列表有一个内置的list.sort()可以直接修改列表。还有一个sorted()内置函数，它会从一个可迭代对象构建一个新的排序列表。list.sort()方法，它会直接修改原列表（并返回 None 以避免混淆），通常来说它不如 sorted()方便 但如果你不需要原列表，它会更有效率。二者都有一个 key 形参来指定在进行比较之前要在每个列表元素上进行调用的函数，接受布尔值的 reverse 参数，这用于标记降序排序。","text":"Python中的index()、find()方法 1str.index(str, beg=0, end=len(string)) 参数 str – 指定检索的字符串 beg – 开始索引，默认为0。 end – 结束索引，默认为字符串的长度。 返回值 如果包含子字符串返回开始的索引值，否则抛出异常。 1str.find(str, beg=0, end=len(string)) 参数 str – 指定检索的字符串 beg – 开始索引，默认为0。 end – 结束索引，默认为字符串的长度。 返回值 如果包含子字符串返回开始的索引值，否则返回-1。 find不能用于list Pthon中的list.sort()、sorted()方法 Python 列表有一个内置的list.sort()可以直接修改列表。还有一个sorted()内置函数，它会从一个可迭代对象构建一个新的排序列表。list.sort()方法，它会直接修改原列表（并返回 None 以避免混淆），通常来说它不如 sorted()方便 但如果你不需要原列表，它会更有效率。二者都有一个 key 形参来指定在进行比较之前要在每个列表元素上进行调用的函数，接受布尔值的 reverse 参数，这用于标记降序排序。 Python中的collections.Counter 一个 Counter 是一个 dict的子类，用于计数可哈希对象。它是一个集合，元素像字典键一样存储，它们的计数存储为值 12&gt;&gt;&gt; Counter('gallahad')Counter(&#123;'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1&#125;) 计数器对象除了字典方法以外，还提供了三个其他的方法： elements() 返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，将会忽略它 123&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)&gt;&gt;&gt; list(c.elements())['a', 'a', 'a', 'a', 'b', 'b'] most_common([n]) 返回一个列表，其中包含 n 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 n 被省略或为 None，most_common() 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序 12&gt;&gt;&gt; Counter('abracadabra').most_common(3)[('a', 5), ('b', 2), ('r', 2)] subtract([iterable-or-mapping]) 从 迭代对象 或 映射对象 减去元素。像 dict.update() ，但是是减去，而不是替换。输入和输出都可以是0或者负数 12345&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)&gt;&gt;&gt; d = Counter(a=1, b=2, c=3, d=4)&gt;&gt;&gt; c.subtract(d)&gt;&gt;&gt; cCounter(&#123;'a': 3, 'b': 0, 'c': -3, 'd': -6&#125;) Python中的位运算 运算符 说明 &lt;&lt; 按位左移，左移相当于乘以2的n次方 &gt;&gt; 按位右移，右移相当于除以2的n次方 &amp; 按位与，二进制位数相同且为1结果位为1 | 按位或，二进制位数或有1结果位为1 ^ 按位异或，二进制位数不同结果位为1 ~ 按位取反，二进制位0和1结果位互换 异或运算三个性质： 1.任何数和0做异或运算，结果仍然是原来的数。a^0=a 2.任何数和其自身做异或运算，结果是0。a^a=0 3.异或运算满足交换律和结合律。a^b^a=b^a^a=b^(a^a)=b^0=b 根据与运算定义，设二进制数字n，则有： 若n&amp;1=0，则二进制最右位为0 若n&amp;1=1，则二进制最右位为1 原码表示法在数值前面增加了一位符号位（即最高位符号位）：正数该位为0，负数该位为1 原码：一个正数，转换为二进制位就是这个正数的原码。负数的绝对值转换成二进制位然后在高位补1就是这个负数的原码 反码：正数的反码就是原码，负数的反码等于原码除符号位以外所有位取反 补码：正数的补码与原码相同，负数的补码为其原码除符号位外所有位取反（这就是反码了），然后最低位加1 正数的反码和补码都与原码相同 负数的反码为该数的原码除符号位外所有位取反 负数的补码为该数的原码除符号位外所有位取反，然后最低位加1 Python字符串 python转义字符：在需要在字符中使用特殊字符时，python 用反斜杠 \\ 转义字符 转义字符 描述 (在行尾时) 续行符 \\ 反斜杠符号 &#39; 单引号 &quot; 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 python字符串运算 操作符 描述 实例 + 字符串连接 &gt;&gt;&gt;a + b ‘HelloPython’ * 重复输出字符串 &gt;&gt;&gt;a * 2 ‘HelloHello’ [] 通过索引获取字符串中字符 &gt;&gt;&gt;a[1] ‘e’ [ : ] 截取字符串中的一部分 &gt;&gt;&gt;a[1:4] ‘ell’ in 成员运算符 - 如果字符串中包含给定的字符返回 True &gt;&gt;&gt;”H” in a True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True &gt;&gt;&gt;”M” not in a True r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 &gt;&gt;&gt;print r’\\n’ python字符串格式化 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %F 和 %E 的简写 %p 用十六进制数格式化变量的地址 Python 中三引号可以将复杂的字符串进行赋值。 Python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。 三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。 123456789101112131415 errHTML = '''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=BackONCLICK=\"window.history.back()\"&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;'''cursor.execute('''CREATE TABLE users ( login VARCHAR(8), uid INTEGER,prid INTEGER)''') Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单： 12&gt;&gt;&gt; u'Hello World !'u'Hello World !' python的字符串内建函数 方法 描述 string.capitalize() 把字符串的第一个字符大写 string.center(width) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 string.count(str, beg=0, end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 string.decode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’ string.encode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ string.endswith(obj, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. string.expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。 string.find(str, beg=0, end=len(string)) 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 string.format() 格式化字符串 string.index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在 string中会报一个异常. string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False string.isdecimal() 如果 string 只包含十进制数字则返回 True 否则返回 False. string.isdigit() 如果 string 只包含数字则返回 True 否则返回 False. string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False string.isnumeric() 如果 string 中只包含数字字符，则返回 True，否则返回 False string.isspace() 如果 string 中只包含空格，则返回 True，否则返回 False. string.istitle() 如果 string 是标题化的(见 title())则返回 True，否则返回 False string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 string.ljust(width) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 string.lower() 转换 string 中所有大写字符为小写. string.lstrip() 截掉 string 左边的空格 string.maketrans(intab, outtab]) maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 string.partition(str) 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 ，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串。(string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string. string.replace(str1, str2, num=string.count(str1)) 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. string.rfind(str, beg=0,end=len(string) ) 类似于 find()函数，不过是从右边开始查找. string.rindex( str, beg=0,end=len(string)) 类似于 index()，不过是从右边开始. string.rjust(width) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 string.rpartition(str) 类似于 partition()函数,不过是从右边开始查找 string.rstrip() 删除 string 字符串末尾的空格. string.split(str=””, num=string.count(str)) 以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串 string.splitlines([keepends]) 按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 string.startswith(obj, beg=0,end=len(string)) 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查. string.strip([obj]) 在 string 上执行 lstrip()和 rstrip() string.swapcase() 翻转 string 中的大小写 string.title() 返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) string.translate(str, del=””) 根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中 string.upper() 转换 string 中的小写字母为大写 string.zfill(width) 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 12345678from string import maketrans # 引用 maketrans 函数。 intab = \"aeiou\"outtab = \"12345\"trantab = maketrans(intab, outtab) str = \"this is string example....wow!!!\";print str.translate(trantab); Python列表 列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表 列表函数&amp;方法： 序号 函数 2 len(list) 列表元素个数 3 max(list) 返回列表元素最大值 4 min(list) 返回列表元素最小值 5 list(seq) 将元组转换为列表 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 Python字典 Python字典包含了以下内置函数： 序号 函数及描述 实例 1 len(dict) 计算字典元素个数，即键的总数。 &gt;&gt;&gt; dict = {&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} &gt;&gt;&gt; len(dict) 3 2 str(dict) 输出字典，以可打印的字符串表示。 &gt;&gt;&gt; dict = {&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} &gt;&gt;&gt; str(dict) &quot;{&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7}&quot; 3 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 &gt;&gt;&gt; dict = {&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} &gt;&gt;&gt; type(dict) Python字典包含了以下内置方法： 序号 函数及描述 1 radiansdict.clear() 删除字典内所有元素 2 radiansdict.copy() 返回一个字典的浅复制 3 radiansdict.fromkeys(seq[, value])创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 4 radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5 key in dict 如果键在字典dict里返回true，否则返回false 6 radiansdict.items() 以列表返回可遍历的(键, 值) 元组数组 7 radiansdict.keys() 返回一个迭代器，可以使用 list() 来转换为列表 8 radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里 10 radiansdict.values() 返回一个迭代器，可以使用 list() 来转换为列表 11 pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 随机返回并删除字典中的最后一对键和值。 Python元组 元组与列表的区别，元组它的关键是不可变性。 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python元组包含了以下内置函数 序号 方法及描述 2 len(tuple) 计算元组元素个数。 3 max(tuple) 返回元组中元素最大值。 4 min(tuple) 返回元组中元素最小值。 5 tuple(seq) 将列表转换为元组。","categories":[],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://afulla.github.io/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"title":"Python之属性描述符","slug":"Python之属性描述符","date":"2020-01-06T09:58:02.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2020/01/06/Python之属性描述符/","link":"","permalink":"https://afulla.github.io/2020/01/06/Python%E4%B9%8B%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"仅当无法使用常规的方式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会调用特殊的__getattr__方法 用于构建实例的是特殊方法__new__：这个是类方法，必须返回一个实例。返回的实例作为第一个参数（即__self__）传给__init__方法。因为调用__init__方法时要传入实例，而且禁止返回任何值，所以__init__方法其实是“初始化方法，真正的构造方法是__new__ 去除重复的方法是抽象，抽象特性的定义有两种方式：使用特性工厂函数，或者使用描述符类。其实，特性本身就是使用描述符类实现的。 特性都是类属性，但是特性管理的其实是实例属性的存取。如果实例和所属的类有同名数据属性，那么实例属性会覆盖类属性。 obj.attr这样的表达式不会从obj开始寻找attr，而是从obj.__calss__开始，而且，仅当类中没有名为attr的特性时，Python才会在obj实例中寻找。 影响属性处理方式的特殊属性 __class__ 对象所属类的引用（即obj.__class__与type(obj)的作用相同）。Python的某些特殊方法，如__getattr__，只在对象的类中寻找，而不在实例中寻找。 __dict__ 一个映射，存储对象或类的可写属性。有__dict__属性的对象，任何时候都能随意设置新属性。 __slots__ 类可以定义这个属性，限制实例能有哪些属性。__slots__属性的值是一个字符串组成的元组，指明允许有的属性。如果__slots__中没有__dict__，那么该类的实例没有__dict__属性，实例只允许有指定名称的属性。 处理属性的内置函数 dir([object]) 列出对象的大多数属性 getattr(object, name[, default]) 从object对象中获取name字符串对应的属性。获取的属性可能来自对象所属的类或超类。如果没有指定的属性，getattr函数抛出AttributeError异常，或者返回default参数的值。 hasattr(object, name) 如果object对象中存在指定的属性，或者能以某种方式（例如继承）通过object对象获取指定的属性，返回True setattr(object, name, value) 把object对象指定属性的值设为value，前提是object对象能接受那个值。这个函数可能会创建一个新属性，或者覆盖现有属性。 vars([object]) 返回object对象的__dict__属性；如果实例所属的类定义了__slots__属性，实例没有__dict__属性，那么vars函数不能处理那个实例（相反，dir函数能处理这样的实例）。如果没有指定参数，那么vars()函数的作用与locals()函数一样：返回表示本地作用域的字典。 处理属性的特殊方法 使用点号或内置的getattr、hasattr和setattr函数存取属性都会触发下述列表中的相应特殊方法。但是，直接通过实例的__dict__属性读写属性不会触发这些特殊方法 __delattr__(self, name) 只要使用del语句删除属性，就会调用这个方法 __dir__(self) 把对象传给dir函数时调用，列出属性。 __getattr__(self, name) 仅当获取指定的属性失败，搜索过obj、Class和超类之后调用。表达式 obj.no_such_attr、 getattr(obj, &#39;no_such_attr&#39;) 和hasattr(obj, &#39;no_such_attr&#39;) 可能会触发Class.__getattr__(obj, &#39;no_such_attr&#39;) 方法， 但是， 仅当在obj、 Class 和超类中找不到指定的属性时才会触发。 __getattribute__(self, name) 尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法时除外。点号与getattr和hasattr内置函数会触发这个方法。调用__getattribute__方法且抛出AttributeError异常时，才会调用__getattr__方法。为了在获取obj实例的属性时不导致无限递归，__getattribute__方法的实现要使用super().__getattribute__(obj,name) __setattr__(self, name, value) 尝试设置指定的属性时总会调用这个方法。点号和setattr内置函数会触发这个方法。 其实特殊方法__getattribute__和__setattr__不管怎样都会调用，几乎影响每一次属性存取。 扩展 在导入时，解释器会从上到下一次性解析完.py模块的源码，然后生成用于执行的字节码。如果句法有错误，就在此报告。如果本地的pycache文件夹中有最新的.pyc文件，解释器会跳过上述步骤。import语句不只声明，在进程中首次导入模块时，还会运行所导入模块中的全部顶层代码，以后导入相同模块则使用缓存，只做名称绑定。解释器会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是不会执行函数的定义体。这通常意味着解释器在导入时定义顶层函数，但是仅当在运行时调用函数时才会执行函数的定义体。对类来说，情况不同。在导入时，解释器会执行每个类的定义体。","categories":[],"tags":[{"name":"属性","slug":"属性","permalink":"https://afulla.github.io/tags/%E5%B1%9E%E6%80%A7/"},{"name":"描述符","slug":"描述符","permalink":"https://afulla.github.io/tags/%E6%8F%8F%E8%BF%B0%E7%AC%A6/"}]},{"title":"Python之并发编程","slug":"Python之并发编程","date":"2019-11-13T06:57:30.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/11/13/Python之并发编程/","link":"","permalink":"https://afulla.github.io/2019/11/13/Python%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","excerpt":"","text":"进程 进程是执行中的程序，也就是说进程是动态的，程序是静态的 进程是操作系统分配资源的最小单位，一个进程控制块（PCB），有自己唯一的一个进程标志符（PID） 进程之间相互独立，内存不共享 每个进程都是一个实体，每个进程都有属于自己的一块内存 进程的创建、销毁和切换开销较大 进程只能创建子进程，无法创建平级进程 线程 线程是CPU的基本调度单位 一个进程一般包含多个线程，一个进程下的多个线程共享进程资源 不同进程之间的线程相互不可见 线程不能独立执行 一个线程可以创建和撤销另外一个线程 一个进程至少有一个线程，进程有自己独立的内存单元，而多个线程共享一个内存单元。 Python标准库中所有阻塞型I/O函数都会释放GIL，允许其他线程运行。time.sleep()函数也会释放GIL。因此，尽管有GIL，Python线程还是能在I/O密集型应用中发挥作用。 可使用concurrent.futures模块在CPU密集型作业中绕开GIL。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"协程","slug":"协程","permalink":"https://afulla.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://afulla.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://afulla.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"Python之协程","slug":"Python之协程","date":"2019-11-11T09:21:29.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/11/11/Python之协程/","link":"","permalink":"https://afulla.github.io/2019/11/11/Python%E4%B9%8B%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"并发编程一般使用多线程或者多进程来实现，对于CPU计算密集型任务，由于GIL的存在，通常使用多进程来实现，而对于IO密集型任务，可以通过线程调度来让线程在执行IO任务时让出GIL，从而实现表面上的并发。 对于IO密集型任务还有一种选择就是协程，是运行在单线程中的“并发”，协程相比多线程的一大优势是省去了多线程之间的切换开销，获得了更高的效率。Python中的异步IO模块asyncio就是基本的协程模块。 协程的切换不同于线程切换，是由程序自身控制的，没有切换的开销。协程不需要多线程的锁机制，因为都是在同一个线程中运行，所以没有同时访问数据的问题，执行效率比多线程高很多。可以这么简单地理解：进程/线程：操作系统提供的一种并发处理任务的能力；协程：在代码执行流程中人为地实现多任务并发，是单个线程内的任务调度。多线程和多进程体现的是操作系统的能力，协程体现的是程序员的流程控制能力。 yield的语法规则是：在yield这里暂停函数的执行，并返回yield后面表达式的值（默认为None），直到被next()方法再次调用时，从上次暂停的yield代码处继续往下执行。 每个生成器都可以执行send()方法，为生成器内部的yield语句发送数据。此时yield语句不在只是yield xxx的形式，还可以是var = yield xxx的赋值形式。它同时具备两个功能，一是暂停并返回函数，二是接收外部send()方法发送过来的值，重新激活函数，并将这个值赋值给var变量。 123456789101112131415161718&gt;&gt;&gt; def simple_coroutine(): print('-&gt;启动协程') y = 10 x = yield y print('-&gt;协程接收到了x的值: ', x) &gt;&gt;&gt; my_coro = simple_coroutine()&gt;&gt;&gt; ret = next(my_coro)-&gt;启动协程&gt;&gt;&gt; print(ret)10&gt;&gt;&gt; my_coro.send(20)-&gt;协程接收到了x的值: 20Traceback (most recent call last): File \"&lt;pyshell#9&gt;\", line 1, in &lt;module&gt; my_coro.send(20)StopIteration 协程可以处于下面四个状态中的一个。当前状态可以导入inspect模块，使用inspect.getgeneratorstate(…)方法查看，该方法返回： ‘GEN_CREATED’：等待开始执行 ‘GEN_RUNNING’：协程正在执行 ‘GEN_SUSPENDED’：在yield表达式处暂停 ‘GEN_CLOSED’：执行结束 因为send()方法的参数会成为暂停的yield表达式的值，所以仅当协程处于暂停状态时才能调用send()方法，不过如果协程还没激活（状态是’GEN_CREATED’），就立即把None之外的值发给它，会出现TypeError。因此，始终要先调用next(my_coro)激活协程（也可以调用my_coro.end(None)），这一过程被称作预激活。 通过asyncio可以轻松实现协程来完成异步IO操作。@asyncio.coroutine，asyncio模块中的装饰器，用于将一个生成器声明为协程。asyncio的使用可分三步走： 创建事件循环 指定循环模式并运行 关闭循环 通常使用asyncio.get_event_loop()方法创建一个循环。运行循环有两种方法：一是调用run_until_complete()方法，二是调用run_forever()方法。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"协程","slug":"协程","permalink":"https://afulla.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"Appium工作原理","slug":"Appium工作原理","date":"2019-11-01T03:48:33.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/11/01/Appium工作原理/","link":"","permalink":"https://afulla.github.io/2019/11/01/Appium%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"Appium是一款开源、跨平台的的测试框架，可以用来测试原生及混合的移动端应用。Appium支持iOS、Android及Windows平台，也支持Safari、Chrome和其他安卓浏览器应用。","text":"Appium是一款开源、跨平台的的测试框架，可以用来测试原生及混合的移动端应用。Appium支持iOS、Android及Windows平台，也支持Safari、Chrome和其他安卓浏览器应用。 Appium的设计哲学： 不需要为了自动化而重新编译或修改测试app 不应被限定于某种语言或框架，也就是说任何人都可以使用自己最熟悉最顺手的语言以及框架来做移动端自动化测试 不应为了移动端的自动化测试而重造轮子，也就是说Webdriver协议中的api已经够好了，拿来改进一下就可以了 移动端自动化测试框架应该是开源的 Appium所用技术框架： iOS9.3及以上：XCUITest iOS9.3及以下：UIAutomation Android4.2+：Google’s UiAutomator/UiAutomator2 Windows：Microsoft’s WinAppDriver Appium采用client-server的设计模式，只要client能够发送http请求给server，那么client用什么语言实现都可以，这就是Appium支持多语言的原因，另外，Appium只是扩展了webdriver协议。 Clinet/Server Architecture Appium的核心其实是一个暴露了一系列REST API的server。server监听一个端口，然后接收由client发送来的command。翻译这些command，把这些command转成移动设备可以理解的形式发送给移动设备，然后移动设备执行完这些command后，把结果返回给server，server再把执行结果返回给client。 Session 在webdriver/appium，你的所有工作永远都是在session start后才可以进行的。一般来说，通过POST /session这个URL，然后传入Desired Capabilities就可以开启session了。 Desired Capabilities 是一个key-value形式的对象，携带一些配置信息，告诉server本次测试的上下文，比如进行浏览器测试还是移动端测试，如果是移动端测试的话是测试Android还是iOS，如果是测试Android的话是测试哪个app。 Appium工作原理 当开启Appium服务器的同时就开启了监听端口。运行脚本时，调用任何AppiumAPI，都会向Appium Server端post一条HTTP请求，请求内容是 webdriver wire protocol协议规定的一条JSON格式的数据 。 Appium Server端接收到请求后，解析出JSON数据并发送到手机端。 手机端上已经由BootStrap.jar(iOS为BootStrip.js)开启的socket服务器监听相应的端口，BootStrap.jar在Appium每个session第一次访问手机端的时候会自动安装。 手机端接收到对应的请求后，通过BootStrap.jar翻译成UIAutomator能执行的命令，然后通过UIAutomator处理并操作APP完成测试。","categories":[],"tags":[{"name":"Appium","slug":"Appium","permalink":"https://afulla.github.io/tags/Appium/"}]},{"title":"Python基础记录(10)","slug":"Python基础记录-10","date":"2019-10-31T03:35:18.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/10/31/Python基础记录-10/","link":"","permalink":"https://afulla.github.io/2019/10/31/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-10/","excerpt":"","text":"if 语句之外的else块 else子句不仅能在if语句中使用，还能在for、while和try语句中使用 for 仅当 for 循环运行完毕时（即 for 循环没有被 break 语句中止）才运行 else 块 while 仅当 while 循环因为条件为假值而退出时（即 while 循环没有被break 语句中止） 才运行 else 块 try 仅当 try 块中没有异常抛出时才运行 else 块，else 子句抛出的异常不会由前面的 except 子句处理 在所有情况下，如果异常或者 return、 break 或 continue 语句导致控制权跳到了复合语句的主块之外，else 子句也会被跳过","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python基础记录(9)","slug":"Python基础记录-9","date":"2019-10-30T02:13:12.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/10/30/Python基础记录-9/","link":"","permalink":"https://afulla.github.io/2019/10/30/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-9/","excerpt":"迭代器模式：一种惰性获取数据项的方式，按需一次获取一个数据项 yield关键字用于构建生成器（generator），其作用与迭代器一样，所有生成器都是迭代器，因为生成器完全实现了迭代器接口。Python3中，生成器有广泛的用途，即使是内置的range()函数也返回一个类似生成器的对象，而以前则返回完整的列表。如果一定要让range()函数返回列表，那么必须明确指明 1234&gt;&gt;&gt; range(1, 5)range(1, 5)&gt;&gt;&gt; list(range(1, 5))[1, 2, 3, 4] 在Python中，所有集合都可以迭代。在Python语言内部，迭代器用于支持： for循环 构建和扩展集合类型 逐行遍历文本文件 列表推导、字典推导和集合推导 元组拆包 调用函数时，使用*拆包实参 序列可以迭代的原因：iter函数 解释器需要迭代对象x时，会自动调用iter(x) 检查对象是否实现了__iter__方法，如果实现了就调用它，获取一个迭代器。 如果没有实现__iter__方法，但是实现了__getitem__方法，Python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。 如果尝试失败，Python抛出TypeError异常，通常会提示“x object is not iterable” 任何Python序列都可以迭代的原因是，它们都实现了__getitem__方法。 可迭代对象与迭代器的对比 可迭代对象：使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的__iter__方法，那么对象就是可迭代的。可迭代对象与迭代器的关系：Python从可迭代对象中获取迭代器。标准的迭代器接口有两个方法： __next__：返回下一个可用元素，如果没有元素了，抛出StopIteration异常 __iter__：返回self，以便在应该使用可迭代对象的地方使用迭代器，例如for循环中 迭代器：实现了无参数的__next__方法，返回序列中的下一个元素，如果没有元素了，那么抛出StopIteration异常。Python中的迭代器还实现了__iter__方法，因此迭代器也可以迭代。 可迭代的对象一定不能是自身的迭代器。也就是说，可迭代的对象必须实现__iter__方法，但不能实现__next__方法。另一方面，迭代器应该一直可以迭代，迭代器的__iter__方法应该返回自身 生成器函数工作原理 只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。 生成器表达式 生成器表达式可以理解为列表推导式的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。也就是说列表推导式是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。 标准库中的生成器函数","text":"迭代器模式：一种惰性获取数据项的方式，按需一次获取一个数据项 yield关键字用于构建生成器（generator），其作用与迭代器一样，所有生成器都是迭代器，因为生成器完全实现了迭代器接口。Python3中，生成器有广泛的用途，即使是内置的range()函数也返回一个类似生成器的对象，而以前则返回完整的列表。如果一定要让range()函数返回列表，那么必须明确指明 1234&gt;&gt;&gt; range(1, 5)range(1, 5)&gt;&gt;&gt; list(range(1, 5))[1, 2, 3, 4] 在Python中，所有集合都可以迭代。在Python语言内部，迭代器用于支持： for循环 构建和扩展集合类型 逐行遍历文本文件 列表推导、字典推导和集合推导 元组拆包 调用函数时，使用*拆包实参 序列可以迭代的原因：iter函数 解释器需要迭代对象x时，会自动调用iter(x) 检查对象是否实现了__iter__方法，如果实现了就调用它，获取一个迭代器。 如果没有实现__iter__方法，但是实现了__getitem__方法，Python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。 如果尝试失败，Python抛出TypeError异常，通常会提示“x object is not iterable” 任何Python序列都可以迭代的原因是，它们都实现了__getitem__方法。 可迭代对象与迭代器的对比 可迭代对象：使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的__iter__方法，那么对象就是可迭代的。可迭代对象与迭代器的关系：Python从可迭代对象中获取迭代器。标准的迭代器接口有两个方法： __next__：返回下一个可用元素，如果没有元素了，抛出StopIteration异常 __iter__：返回self，以便在应该使用可迭代对象的地方使用迭代器，例如for循环中 迭代器：实现了无参数的__next__方法，返回序列中的下一个元素，如果没有元素了，那么抛出StopIteration异常。Python中的迭代器还实现了__iter__方法，因此迭代器也可以迭代。 可迭代的对象一定不能是自身的迭代器。也就是说，可迭代的对象必须实现__iter__方法，但不能实现__next__方法。另一方面，迭代器应该一直可以迭代，迭代器的__iter__方法应该返回自身 生成器函数工作原理 只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。 生成器表达式 生成器表达式可以理解为列表推导式的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。也就是说列表推导式是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。 标准库中的生成器函数 os.walk 1os.walk(top, topdown=True, onerror=None, followlinks=False) top-要遍历的目录 topdown-是代表要从上而下遍历还是从下往上遍历 onerror-可以用来设置当遍历出现错误时的处理函数 followlinks-表示是否要跟随目录下的链接去继续遍历。要注意的是，os.walk不会记录已经遍历过的目录，所以跟随链接遍历的话有可能一直循环调用 os.walk生成的是一个3个元素的元组（dirpath, dirnames, filenames)，分别表示遍历的路径名，该路径下的目录列表和该路径下的文件列表。注意目录列表和文件列表不是具体路径，需要具体路径的话，可以用os.path.join(dirpath, name) itertools.compress 1compress(it, selector_it) 并行处理两个可迭代的对象； 如果 selector_it 中的元素是真值， 产出 it 中对应的元素 12345&gt;&gt;&gt; from itertools import compress&gt;&gt;&gt; list(compress('ABCDEF', [1, 1, 0]))['A', 'B']&gt;&gt;&gt; list(compress(['A', 'B', 'c', 'D'], [False, True, True, True, False, True]))['B', 'c', 'D'] itertools.dropwhile 1dropwhile(predicate, it) 处理 it，跳过 predicate 的计算结果为真值的元 素， 然后产出剩下的各个元素 123&gt;&gt;&gt; from itertools import dropwhile&gt;&gt;&gt; list(dropwhile(lambda x: x&lt;4, [1, 2, 3, 4, 5, 6]))[4, 5, 6] itertools.islice 1islice(it, stop) 或 islice(it, start, stop, step=1) 产出 it 的切片， 作用类似于 s[:stop] 或 s[start:stop:step]， 不过 it 可以是任何可迭代 的对象， 而且这个函数实现的是惰性操作 12345&gt;&gt;&gt; from itertools import count, islice&gt;&gt;&gt; list(islice(count(), 6))[0, 1, 2, 3, 4, 5]&gt;&gt;&gt; list(islice(count(), 5, 10, 2))[5, 7, 9] itertools.takewhile 1takewhile(predicate, it) predicate 返回true时产出对应的元素， 返回false时立 即停止， 不再继续检查 123from itertools import takewhile, count&gt;&gt;&gt; list(takewhile(lambda x: x&lt;5, count()))[0, 1, 2, 3, 4] itertools.accumulate 1accumulate(it, [func]) 产出累积的总和； 如果提供了 func， 那么把前两个 元素传给它， 然后把计算结果和下一个元素传给 它， 以此类推， 最后产出结果 12345&gt;&gt;&gt; from itertools import accumulate, operator&gt;&gt;&gt; list(accumulate(range(1, 10)))[1, 3, 6, 10, 15, 21, 28, 36, 45]&gt;&gt;&gt; list(accumulate(range(1, 10), operator.mul))[1, 2, 6, 24, 120, 720, 5040, 40320, 362880] enumerate 1enumerate(iterable, start=0) 产出由两个元素组成的元组， 结构是 (index, item)， 其中 index 从 start 开始计数， item 则从 iterable 中获取 1234&gt;&gt;&gt; enumerate(['a', 'b', 'c', 'd'])&lt;enumerate object at 0x0000000002BDF900&gt;&gt;&gt;&gt; list(enumerate(['a', 'b', 'c', 'd']))[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')] map 1map(func, it1, [it2, ..., itN]) 把 it 中的各个元素传给func， 产出结果； 如果传入 N 个可迭代的对象， 那么 func 必须能接受 N 个参 数， 而且要并行处理各个可迭代的对象 12345678&gt;&gt;&gt; map(lambda x:x+2, [1, 2, 3, 4])&lt;map object at 0x0000000002BD49B0&gt;&gt;&gt;&gt; list( map(lambda x:x+2, [1, 2, 3, 4]))[3, 4, 5, 6]&gt;&gt;&gt; list(map(lambda x, y:x+y, [1, 2, 3, 4], [2]))[3]&gt;&gt;&gt; list(map(lambda x, y:x+y, [1, 2, 3, 4], [2, 3, 4, 5]))[3, 5, 7, 9] itertools.starmap starmap()与map()间的区别可以类比 function(a,b) 与 function(*c) 的区别 123&gt;&gt;&gt; from itertools import starmap&gt;&gt;&gt; list(starmap(lambda x, y:x+y, [(1,2), (2,3), (3,4), (4,5)]))[3, 5, 7, 9] itertools.chain 1chain(it1, ..., itN) 先产出 it1 中的所有元素， 然后产出 it2 中的 所有元素， 以此类推， 无缝连接在一起 123&gt;&gt;&gt; from itertools import chain&gt;&gt;&gt; list(chain([1, 2], [4, 5, 6]))[1, 2, 4, 5, 6] chain.from_iterable 1chain.from_iterable(it) 产出 it 生成的各个可迭代对象中的元素， 一个 接一个， 无缝连接在一起； it 应该产出可迭代 的元素， 例如可迭代的对象列表 12345&gt;&gt;&gt; from itertools import chain&gt;&gt;&gt; list(chain.from_iterable(['abc']))['a', 'b', 'c']&gt;&gt;&gt; list(chain.from_iterable(['abc', 'def']))['a', 'b', 'c', 'd', 'e', 'f'] zip 1zip(it1, ..., itN) 并行从输入的各个可迭代对象中获取元素， 产 出由 N 个元素组成的元组， 只要有一个可迭代 的对象到头了， 就默默地停止 1234&gt;&gt;&gt; list(zip('abc' ,'def'))[('a', 'd'), ('b', 'e'), ('c', 'f')]&gt;&gt;&gt; list(zip([1, 2, 3], ['a', 'b', 'c']))[(1, 'a'), (2, 'b'), (3, 'c')] itertools.zip_longest 1zip_longest(it1, ...,itN, fillvalue=None) 并行从输入的各个可迭代对象中获取元素， 产 出由 N 个元素组成的元组， 等到最长的可迭代 对象到头后才停止， 空缺的值使用 fillvalue 填充 123&gt;&gt;&gt; from itertools import zip_longest&gt;&gt;&gt; list( zip_longest([1, 2, 3], ['a', 'b'], fillvalue='c'))[(1, 'a'), (2, 'b'), (3, 'c')] itertools.combinations 1combinations(it, out_len) 把 it 产出的 out_len 个元素组合在 一起， 然后产出 123&gt;&gt;&gt; from itertools import combinations&gt;&gt;&gt; list(combinations('ABC', 2))[('A', 'B'), ('A', 'C'), ('B', 'C')] itertools.combinations_with_replacement 1combinations_with_replacement(it, out_len) 把 it 产出的 out_len 个元素组合在 一起， 然后产出， 包含相同元素的 组合 123&gt;&gt;&gt; from itertools import combinations_with_replacement&gt;&gt;&gt; list(combinations_with_replacement('ABC', 2))[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')] itertools.count 1count(start=0, step=1) 从 start 开始不断产出数字， 按 step 指定的步幅增加 itertools.groupby 1groupby(it,key=None) 产出由两个元素组成的元素， 形式为 (key, group)， 其中 key 是分组标准， 如果不指定，则默认对 it中的连续相同项进行分组， group 是生成器， 用于产出分组里的元素。 12345678910111213&gt;&gt;&gt; from itertools import groupby&gt;&gt;&gt; list(groupby('aaaabbbbbccccd'))[('a', &lt;itertools._grouper object at 0x0000000002BD4BE0&gt;), ('b', &lt;itertools._grouper object at 0x0000000002BD4B70&gt;), ('c', &lt;itertools._grouper object at 0x0000000002BD48D0&gt;), ('d', &lt;itertools._grouper object at 0x0000000002BD4C18&gt;)]&gt;&gt;&gt; for key, group in groupby('aaaabbbbbccccd'): print(key, ': ', list(group)) a : ['a', 'a', 'a', 'a']b : ['b', 'b', 'b', 'b', 'b']c : ['c', 'c', 'c', 'c']d : ['d']&gt;&gt;&gt; for key, group in groupby([&#123;'a':1&#125;, &#123;'a':2&#125;, &#123;'c':3&#125;], lambda x:'a' in x): print(key, ': ', list(group)) True : [&#123;'a': 1&#125;, &#123;'a': 2&#125;]False : [&#123;'c': 3&#125;] reversed 从后向前， 倒序产出 seq 中的元素； seq 必须是序 列， 或者是实现了 __reversed__ 特殊方法的对象 1234&gt;&gt;&gt; list(reversed('12345'))['5', '4', '3', '2', '1']&gt;&gt;&gt; list(reversed([1,2,3,4,5]))[5, 4, 3, 2, 1] yield from 可使生成器函数产出另一生成器生成的值 可迭代的归约函数 读取迭代器，返回单个值的内置函数 all(it) it 中的所有元素都为真值时返回 True， 否则返回 False； all([]) 返回 True any(it) 只要 it 中有元素为真值就返回 True， 否则返回 False； any([]) 返回 False max(it, [key=,] [default=] 返回 it 中值最大的元素； key 是排序函数， 与 sorted 函 数中的一样； 如果可迭代的对象为空， 返回 default 12345678910&gt;&gt;&gt; max([1, 2, 3])3&gt;&gt;&gt; max([1, 2, -3], key=lambda x: abs(x))-3&gt;&gt;&gt; max(zip(prices.keys(), prices.values()))('E', 444)&gt;&gt;&gt; max(zip(prices.values(), prices.keys()))(450.1, 'B')&gt;&gt;&gt; max(prices, key=lambda k:prices[k])'B' min(it, [key=,] [default=] 返回 it 中值最小的元素； key 是排序函数， 与 sorted 函 数中的一样； 如果可迭代的对象为空， 返回 default functools.reduce(func,it,[initial]) 把前两个元素传给 func， 然后把计算结果和第三个元素传 给 func， 以此类推， 返回最后的结果； 如果提供了 initial， 把它当作第一个元素传入 12345&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x,y:x+y, [1,2,3,4,5])15&gt;&gt;&gt; reduce(lambda x,y:x+y, [1,2,3,4,5], -1)14 sum(it,start=0) it 中所有元素的总和， 如果提供可选的 start， 会把它加 上（计算浮点数的加法时， 可以使用 math.fsum 函数提高 精度）","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"生成器","slug":"生成器","permalink":"https://afulla.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8/"}]},{"title":"Windows远程连接Mac","slug":"Windows远程连接Mac","date":"2019-10-26T03:43:46.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/10/26/Windows远程连接Mac/","link":"","permalink":"https://afulla.github.io/2019/10/26/Windows%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Mac/","excerpt":"","text":"Windows远程连接Mac,主要依赖VNC图形桌面共享系统。Mac系统自带VNC Client，Windows通过安装TightVNC Viewer等客户端来进行连接。 Mac打开“系统偏好设置”–“共享” 勾选“屏幕共享”-“电脑设置” Windows下载TightVNV Viewer等客户端进行连接 输入设置的屏幕控制密码 至此就可以从Windows连接到Mac了","categories":[],"tags":[]},{"title":"Python之禅","slug":"Python之禅","date":"2019-10-23T07:10:39.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/10/23/Python之禅/","link":"","permalink":"https://afulla.github.io/2019/10/23/Python%E4%B9%8B%E7%A6%85/","excerpt":"","text":"这是一个彩蛋 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#39;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#39;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#39;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#39;s do more of those!","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python之抽象类","slug":"Python之抽象类","date":"2019-09-27T07:53:19.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/09/27/Python之抽象类/","link":"","permalink":"https://afulla.github.io/2019/09/27/Python%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"抽象基类（Abstract Base Class），主要定义了基本类和最基本的抽象方法，可以为子类定义共有的API，不需要具体实现。抽象基类可以不实现具体的方法（当然也可以实现，只不过子类如果想调用抽象基类中定义的方法，需要使用super()），而是将其留给派生类实现。从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。 Python对于ABC的支持模块是abc模块，常用的： abc.ABCMeta：用来生成抽象基类的元类 @abc.abstractmethod：定义抽象方法 具体化抽象类可以有两种方式：一种通过注册，另外一种通过继承。继承时，除非子类实现抽象基类的所有抽象方法，否则子类不能实例化。但将其他的类“注册”到抽象基类下当虚拟子类时，可以只实现抽象基类中的部分API或根本不实现，但是issubclass()， issubinstance()进行判断时仍然返回真值。注册方式的缺点是不能通过super()调用抽象方法。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python之面向对象编程","slug":"Python之面向对象编程","date":"2019-09-10T08:44:41.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/09/10/Python之面向对象编程/","link":"","permalink":"https://afulla.github.io/2019/09/10/Python%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程编程：数据和处理数据的函数是彼此独立的，我们需要先将数据处理成函数能接受的格式，再调用相关函数处理 面向对象编程：数据和处理数据的函数都放在一个类中（Class)，通过初始化实例（Instance）传递数据，通过实例调用对象方法或者说叫实例方法。 数据封装、继承和多态是面向对象的三大特点。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类是创建实例的模板，而实例则是一个个具体的对象，各个实例拥有的数据互相独立，互不影响。方法就是实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据。通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。 1234567891011121314class Employee: '所有员工的基类' empCount = 0 # 类变量，可通过Employee.empCount访问 def __init__(self, name, salary): # self指向创建的实例本身 self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): # 类中定义的函数，第一个参数为实例变量self print \"Total Employee %d\" % Employee.empCount def displayEmployee(self): print \"Name : \", self.name, \", Salary: \", self.salary 12345e = Employee() # 创建Employe实例e.empCount # 输出0，因为实例并没有empCount属性，所以会继续查找class的empCount属性e.empCount = 1 # 给实例绑定empCount属性e.empCount # 输出1， 实例属性优先级高于类属性Employee.empCount # 输出0，类属性仍存在 可使用__slots__变量来限制class实例能绑定的属性 12class Employee: __slots__ = ('empCount1', 'empCount2') __slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__ Python内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是’__main__.className‘，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 单下划线、双下划线、头尾双下划线说明： __foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__()之类的。 _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import * __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。 获取对象信息 type()可以检查类型 isinstance()可以方便对比类型 dir()可以获得对象的所有属性和方法 使用__repr__ 和 __str__改变输出123class Employee: def __init__(self, name): self.name = name 12&gt;&gt;&gt; print(Employee('test'))&lt;__main__.Employee object at 0x0000000002BBBEF0&gt; 123456class Employee: def __init__(self, name): self.name = name def __str__(self): return 'Student name is %s' % self.name __repr__ = __str__ 1234&gt;&gt;&gt; print(Employee('test'))Student name is test&gt;&gt;&gt; Employee('test')Student name is test 使用type()动态创建类123def fn(self, name='world'): print('Hello, %s' % name)Hello = type('Hello', (object,), dict(hello=fn)) class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。要创建一个class对象，type()函数依次传入3个参数： class的名称 继承的父类集合 class的方法名称与函数绑定 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class.","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python之鸭子类型","slug":"Python之鸭子类型","date":"2019-09-09T01:48:52.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/09/09/Python之鸭子类型/","link":"","permalink":"https://afulla.github.io/2019/09/09/Python%E4%B9%8B%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"动态语言与静态语言 静态类型语言在编译时便已确定变量的类型，而动态语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。 123String s = 'hello' s = 'hi' s = 0 //编译时会报错 123s = 'hello's = 0s = [1, 2, 3] #可以给变量随意赋值 静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误；其次，如果在程序中明确地规定了数据类型，编辑器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高的程序的一种手段，而不是编写程序的目的；其次，类型声明会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。 动态类型语言的优点是编写的代码数量更少，看起来更加简洁，程序员可以把更多的精力放在业务逻辑上。动态类型语言的缺点是无法保证变量的类型，从而在程序运行期有可能发生跟类型相关的错误。 鸭子类型 鸭子类型是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现的接口决定，而是由当前方法和属性的集合决定。（当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子）在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。例如：在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为“鸭子”的对象，并调用它的“走”和“叫”方法。在使用鸭子类型的语言中，这样的一个函数可以接受任意类型的对象，并调用它们的“走”和“叫”方法。如果这些需要被调用的方法不存在，那么将引发一个运行时的错误。 鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档，清晰的代码和测试来确保正确使用。 利用鸭子类型的思想，能轻松地在动态类型语言中实现一个原则：面向接口编程，而不是面向实现编程。例如：一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当做栈来使用。 接口在动态类型语言中是怎么运作的呢？首先，基本的事实是，Python语言没有Interface关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如getitem。按照定义，受保护的属性和私有属性不在接口中。关于接口，有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。一个类可能会实现多个接口，从而让实例扮演多个角色。 鸭子类型：对象的类型无关紧要，只要实现了特定的协议即可。（忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义）","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"缓存杂谈","slug":"缓存杂谈","date":"2019-07-27T04:01:23.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/07/27/缓存杂谈/","link":"","permalink":"https://afulla.github.io/2019/07/27/%E7%BC%93%E5%AD%98%E6%9D%82%E8%B0%88/","excerpt":"缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。 HTTP缓存概述通过网络获取资源，是一件耗时的操作，较大的资源还会需要客户端和服务端之间进行多次往返通信，这不但增加客户端的响应时间，而且还会增加网络流量。缓存是性能优化的重要方面，合理缓存的好处：（1）缓解服务器压力；（2）加快静态资源加载速度和页面渲染速度；（3）减少带宽消耗 HTTP协议中，就有对缓存的支持，浏览器也都自带了HTTP缓存实现功能。 HTTP缓存主要是通过请求和响应报文头中的对应Header信息来控制缓存策略。 一些概念： 新鲜度（过期机制）：缓存副本有效期。在该有效期之前，该缓存副本就是新鲜的，当过了有效期后，该缓存副本则变为陈旧的。驱逐算法用于将陈旧的缓存副本替换为新鲜的。当客户端发起一个请求时，缓存检索到已有一个对应的陈旧缓存副本，则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。 校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。 缓存命中率：一个缓存的有效性是依照缓存的命中率来度量。","text":"缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。 HTTP缓存概述通过网络获取资源，是一件耗时的操作，较大的资源还会需要客户端和服务端之间进行多次往返通信，这不但增加客户端的响应时间，而且还会增加网络流量。缓存是性能优化的重要方面，合理缓存的好处：（1）缓解服务器压力；（2）加快静态资源加载速度和页面渲染速度；（3）减少带宽消耗 HTTP协议中，就有对缓存的支持，浏览器也都自带了HTTP缓存实现功能。 HTTP缓存主要是通过请求和响应报文头中的对应Header信息来控制缓存策略。 一些概念： 新鲜度（过期机制）：缓存副本有效期。在该有效期之前，该缓存副本就是新鲜的，当过了有效期后，该缓存副本则变为陈旧的。驱逐算法用于将陈旧的缓存副本替换为新鲜的。当客户端发起一个请求时，缓存检索到已有一个对应的陈旧缓存副本，则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。 校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。 缓存命中率：一个缓存的有效性是依照缓存的命中率来度量。 HTTP中和缓存相关的头部字段1.通用首部字段 字段名称 说明 Cache-Control 控制缓存具体行为 Date 创建报文的日期时间（启发式缓存阶段会用到这个字段） Pragma HTTP1.0时的遗留字段，当值为”no-cache”时强制验证缓存。Chrome和Firefox中Pragma的优先级高于Cache-Control和Expires 通过Cache-Control的指令可以告知客户端或服务端如何处理缓存。 作为请求首部时，常见可选值： 指令 参数 说明 no-cache - 强制源服务器再次验证 no-store - 不缓存请求或是响应的任何内容 max-age=[秒] 缓存时长，单位是秒 缓存的时长，也是响应的最大的Age值 min-fresh=[秒] 单位是秒 期望在指定时间内响应仍然有效 作为响应首部时，常见可选值： 指令 参数 说明 public - 任意一方都能缓存该资源(客户端、代理服务器等) private - 只能特定用户缓存该资源 no-cache - 缓存前必须先确认其有效性 no-store - 不缓存请求或响应的任何内容 must-revalidate - 可缓存但必须再向源服务器进行确认 proxy-revalidate - 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=[秒] 缓存时长，单位是秒 缓存的时长，也是响应的最大的Age值 s-maxage=[秒] 单位是秒 公共缓存服务器响应的最大Age值 max-age=0是告诉客户端资源的缓存到期应该向服务器验证缓存的有效性。而no-cache则告诉客户端使用缓存前必须向服务器验证缓存的有效性 2.请求首部字段 字段名称 说明 If-Match 条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改(比较ETag是否一致) If-None-Match 和If-Matcg相反，比较ETag是否不一致 If-Modified-Since 比较资源前后两次访问最后的修改时间是否一致 If-Unmodified-Since 和If-Modified-Since相反 3.响应首部字段 字段名称 说明 ETag 服务器生成资源的唯一标识 Vary 代理服务器缓存的管理信息 Age 资源在缓存代理中存贮的时长 4.实体首部字段 字段名称 说明 Expires 告知客户端资源缓存失效的绝对时间 Last-Modified 资源最后一次修改的时间 缓存机制：强缓存与协商缓存1.基本原理 浏览器在加载资源时，根据请求头的Expires和Cache-Control判断是否命中强缓存，如命中则从缓存读取资源，不会发请求到服务器。 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过Last-Modified和ETag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源 如果前两者都没有命中，直接从从服务器加载资源 2.相同点 如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源 3.不同点 强缓存不发送请求到服务器，协商缓存会发送请求到服务器 强缓存对于强缓存来说，响应头中有两个字段Expires、Cache-Control来表明规则。 1.查看缓存是否有Cache-Control的s-maxage或max-age指令，若有，则使用响应报文生成时间Date + s-maxage/max-age获得过期时间，再与当前时间进行对比（s-maxage适用于多用户使用的公共缓存服务器） 2.如果没有Cache-Control的s-maxage或max-age指令，则比较Expires中的过期时间与当前时间。Expires是一个绝对时间 在HTTP/1.1中，当首部字段Cache-Control有指定s-maxage或max-age指令，比起首部字段Expires，会优先处理s-maxage或max-age *（响应报文头部信息中与强缓存相关的标识字段）* Expires与Cache-Control的区别 Expires是HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用。以时刻标识失效时间，时间是由服务器发送的，如果服务器时间和客户端时间存在不一致，可能会出现问题 Cache-Control是HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。比Expires多了很多选项设置 协商缓存当浏览器发现缓存过期后，缓存并不一定不能使用了，因为服务器端的资源可能仍然没有改变，所以需要与服务器协商，让服务器判断本地缓存是否还能使用。 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。 【ETag、If-None-Match】优先级高于【Last-Modified，If-Modified-Since】 Last-Modified：服务器在响应请求时，响应报文头部带上这个标志，告诉浏览器资源的最后修改时间 If-Modified-Since：再次请求服务器时，请求报文头部带上这个标志，通过该标志通知服务器上次请求时，服务器返回的资源最后修改时间 服务器收到请求后发现有If-Modified-Since 标志，则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源被改动过，则响应新资源内容，返回状态码200；若资源的最后修改时间等于If-Modified-Since，说明资源无新修改，返回状态码304，告知浏览器继续使用所保存的cache *（响应报文头部信息中带上Last-Modified标识，再次请求时，请求报文头部信息中带上If-Modified-Since标识，两值比较相等，不再请求服务器，返回304状态码）* Last-Modified 存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为If-Modified-Since时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源），ETag可以解决这个问题 Etag：就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的 If-None-Match：再次请求服务器时，请求报文头部带上这个标志，询问该资源的ETag是否有更新。 服务器会比对ETag与If-None-Match的值是否一致，如果不一致，服务器则接受请求，返回更新后的资源；如果一致，表明资源未更新，则返回状态码为304的响应，可继续使用本地缓存 *（响应报文头部信息中带上ETag标识，再次请求时，请求报文头部信息中带上ETag标识，两值比较相等，不再请求服务器，返回304状态码）* Last-Modified和ETag的区别 某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 Last-modified 只能精确到秒 一些资源的最后修改时间改变了，但是内容没改变0 Etag 的精度比 Last-Modified 高，属于强验证，要求资源字节级别的一致，优先级高。计算ETag值会造成一定的性能损耗 强缓存与协商缓存整体流程 用户操作行为与缓存 用户操作 Expires/Cache-Control Last-Modified/ETag 地址栏回车 有效 有效 页面链接跳转 有效 有效 新开窗口 有效 有效 前进后退 有效 有效 F5刷新 无效 有效 Ctrl+F5强制刷新 无效 无效 强制刷新 – 当按下Ctrl+F5来刷新页面的时候,，浏览器将跳过强缓存和协商缓存，直接从服务器加载资源 普通刷新 – 当按下F5来刷新页面的时候，跳过强缓存，但会检查协商缓存 请求被缓存，导致新代码不生效时可以如何处理？ 服务端响应报文头部添加Cache-Control:no-cache,must-revalidate指令； 修改请求报文头部If-Modified-Since:0或If-None-Match； 修改请求URL，请求URL后加随机数，随机数可以是时间戳，哈希值，比如：https://pic.my4399.com/js/core.js?t=1234 合理使用缓存可考虑缓存的内容： css样式文件 js文件 logo、图标 html文件 可以下载的内容 不应该缓存的内容： 业务敏感的 GET 请求 CDN缓存CDN缓存是一种服务端缓存，CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上，当用户访问相应的业务资源时，用户会被调度至最接近的节点.在web性能优化中，它主要起到了缓解源站压力和优化不同用户的访问速度与体验的作用。","categories":[],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://afulla.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"Python之弱引用","slug":"Python之弱引用","date":"2019-07-24T11:23:19.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/07/24/Python之弱引用/","link":"","permalink":"https://afulla.github.io/2019/07/24/Python%E4%B9%8B%E5%BC%B1%E5%BC%95%E7%94%A8/","excerpt":"Python中的垃圾回收1.引用计数：CPython中的垃圾回收主要算法，每个对象都会统计有多少引用指向自己，当计数归零时，对象立即销毁。 2.分代垃圾回收：CPython2.0增加的新算法，用于检测引用循环中涉及的对象群组。 del语句删除的是名称，而不是对象。但是在两种情况下可能导致对象被回收： 1.删除的变量保存的是对象的最后一个引用。 2.删除变量后无法得到对象，如两个对象相互引用。 重新绑定也可能会导致对象的引用数量归零。 由于一次仅能有一个对象被回收，引用计数无法回收循环引用的对象。一组相互引用的对象若没有被其它对象直接引用，并且不可访问，则会永久存活下来。一个应用程序如果持续地产生这种不可访问的对象群组，就会发生内存泄漏。在对象群组内部使用弱引用（即不会在引用计数中被计数的引用）有时能避免出现引用环，因此弱引用可用于解决循环引用的问题。Python在对象的引用计数为0或只存在对象的弱引用时将回收这个对象。","text":"Python中的垃圾回收1.引用计数：CPython中的垃圾回收主要算法，每个对象都会统计有多少引用指向自己，当计数归零时，对象立即销毁。 2.分代垃圾回收：CPython2.0增加的新算法，用于检测引用循环中涉及的对象群组。 del语句删除的是名称，而不是对象。但是在两种情况下可能导致对象被回收： 1.删除的变量保存的是对象的最后一个引用。 2.删除变量后无法得到对象，如两个对象相互引用。 重新绑定也可能会导致对象的引用数量归零。 由于一次仅能有一个对象被回收，引用计数无法回收循环引用的对象。一组相互引用的对象若没有被其它对象直接引用，并且不可访问，则会永久存活下来。一个应用程序如果持续地产生这种不可访问的对象群组，就会发生内存泄漏。在对象群组内部使用弱引用（即不会在引用计数中被计数的引用）有时能避免出现引用环，因此弱引用可用于解决循环引用的问题。Python在对象的引用计数为0或只存在对象的弱引用时将回收这个对象。 Python弱引用weakref.ref()可用来创建弱引用，但最好使用finalize、WeakKeyDictionary、WeakValueDictionary等来创建。 sys.getrefcount()可查看对象的引用计数。 12345import sysimport weakrefclass Foo(object): def show(self): print('hello') 1234A = Foo()print('Refcnt of A: ', sys.getrefcount(A))&gt;&gt;&gt;Refcnt of A: 2 123456B = weakref.ref(A)print(B)print('Refcnt of A: ', sys.getrefcount(A)) #引用计数不会增加&gt;&gt;&gt;&lt;weakref at 0x0000000004B3C868; to 'Foo' at 0x0000000004B23DA0&gt;Refcnt of A: 2 weakref.finanlize()可注册一个回调函数，在对象销毁时调用。 123import weakrefclass Human(object): pass 1234john = Human()weakref.finalize(john, print, 'You kill John!')&gt;&gt;&gt;finalize object at 0x499d90; for 'Human' at 0x4f937f0&gt; 123del john&gt;&gt;&gt;You kill John! 弱引用解决循环引用无法被回收的问题 12345import weakrefclass Object(object): _obj = None def store(self, obj): self._obj = obj 12345678A = Object()B = Object()A.store(B) #循环引用B.store(A)a = weakref.ref(A)b = weakref.ref(B)A = None B = None 1234a #任然存活&gt;&gt;&gt;&lt;weakref at 0x0000000004B3C868; to 'Object' at 0x0000000004FB9048&gt;b&gt;&gt;&gt;&lt;weakref at 0x0000000004FB5318; to 'Object' at 0x0000000004F93FD0&gt; 通过弱引用改造后 123456import weakrefclass Object(object): _obj = None def store(self, obj): self._obj = weakref.ref(obj).... 1234a #被销毁&gt;&gt;&gt;&lt;weakref at 0x0000000004FB5728; dead&gt;b&gt;&gt;&gt;&lt;weakref at 0x0000000004F96E08; dead&gt; ref和proxy都只可用与维护单个对象的弱引用，如果想同时创建多个对象的弱引用咋办？这时可以使用WeakKeyDictionary和WeakValueDictionary来实现。 WeakValueDictionary类，顾名思义，本质上还是个字典类型，只是它的值类型是弱引用。当这些值引用的对象不再被其他非弱引用对象引用时，那么这些引用的对象就可以通过垃圾回收器进行回收。 弱引用的主要用途是实现保存大对象的高速缓存或映射，但又并希望大对象仅仅因为它出现在高速缓存或映射中而保持存活。 例如，如果有许多大型二进制图像对象，则可能希望将名称与每个对象关联起来。如果使用Python字典将名称映射到图像，或将图像映射到名称，则图像对象将保持活动状态，因为它们在字典中显示为值或键。 weakref模块提供的 WeakKeyDictionary和 WeakValueDictionary类可以替代Python字典，使用弱引用来构造映射，这些映射不会仅仅因为它们出现在映射对象中而使对象保持存活。例如，如果一个图像对象是 WeakValueDictionary中的值，那么当该图像对象的剩余引用是弱映射对象所持有的弱引用时，垃圾回收可以回收该对象并将其在弱映射对象中相应的条目删除。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://afulla.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"弱引用","slug":"弱引用","permalink":"https://afulla.github.io/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"}]},{"title":"Python之装饰器","slug":"Python之装饰器","date":"2019-06-17T09:57:58.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/06/17/Python之装饰器/","link":"","permalink":"https://afulla.github.io/2019/06/17/Python%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"Python中，一切皆为对象，函数也不例外。它可以像整数一样作为其他函数的返回值，也可以像整数一样作为其他函数的参数。由于函数也是一个对象，而且函数对象可以被赋值给变量，所以通过变量也能调用该函数。 12345&gt;&gt;&gt; def now(): print(\"test!\")&gt;&gt;&gt; f = now&gt;&gt;&gt; f()test! 在代码运行期间动态增加功能的方式，称之为装饰器。装饰器本质上是一个函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能。它经常用于有切面需求的场景，比如：插入日志、事务处理、权限校验等。函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。 functools.lru_cache实现了备忘录功能，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python之参数传递","slug":"Python之参数传递","date":"2019-06-13T10:14:37.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/06/13/Python之参数传递/","link":"","permalink":"https://afulla.github.io/2019/06/13/Python%E4%B9%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/","excerpt":"可接受任意数量参数的函数让一个函数接受任意数量的位置参数，可以使用一个*参数。 12def avg(first, *rest): return (first + sum(rest)) / (1+len(rest)) //rest是由其他元素组成的元组 1234&gt;&gt;&gt; avg(1, 2)1.5&gt;&gt;&gt; avg(1, 2, 3, 4)2.5 让一个函数接受任意数量的关键字参数，使用一个以**开头的参数。 12345def make_element(name, value, **attrs): keyvals = [' %s=\"%s\"' % item for item in attrs.items()] attr_str = ''.join(keyvals) element = '&lt;&#123;name&#125;&#123;attrs&#125;&gt;&#123;value&#125;&lt;/&#123;name&#125;&gt;'.format(name=name, attrs=attr_str, value=html.escape(value)) return element 12&gt;&gt;&gt; make_element('item', 'Albatross',size='large', quantity=6)'&lt;item size=\"large\"quantity=\"6\"&gt;Albatross&lt;/item&gt;' 在这里，attrs是一个包含所有被传入进来的关键字参数的字典。","text":"可接受任意数量参数的函数让一个函数接受任意数量的位置参数，可以使用一个*参数。 12def avg(first, *rest): return (first + sum(rest)) / (1+len(rest)) //rest是由其他元素组成的元组 1234&gt;&gt;&gt; avg(1, 2)1.5&gt;&gt;&gt; avg(1, 2, 3, 4)2.5 让一个函数接受任意数量的关键字参数，使用一个以**开头的参数。 12345def make_element(name, value, **attrs): keyvals = [' %s=\"%s\"' % item for item in attrs.items()] attr_str = ''.join(keyvals) element = '&lt;&#123;name&#125;&#123;attrs&#125;&gt;&#123;value&#125;&lt;/&#123;name&#125;&gt;'.format(name=name, attrs=attr_str, value=html.escape(value)) return element 12&gt;&gt;&gt; make_element('item', 'Albatross',size='large', quantity=6)'&lt;item size=\"large\"quantity=\"6\"&gt;Albatross&lt;/item&gt;' 在这里，attrs是一个包含所有被传入进来的关键字参数的字典。 一个 * 参数只能出现在函数定义中最后一个位置参数后面，而 ** 参数只能出现在最后一个参数。有一点要注意，在 * 参数后面仍可以定义其他参数，这就是我们所说的强制性关键字参数。 只接受关键字参数的函数将强制关键字参数放到某个 * 参数或者单个 * 后面。 12345678&gt;&gt;&gt; def recv(maxsize, *, block): pass&gt;&gt;&gt; recv(1024, True)Traceback (most recent call last): File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt; recv(1024, True)TypeError: recv() takes 1 positional argument but 2 were given&gt;&gt;&gt; recv(1024, block=True) #OK 给函数参数增加元信息1234567&gt;&gt;&gt; def add(x:int, y:int) -&gt; int: return x + y&gt;&gt;&gt; help(add)Help on function add in module __main__:add(x:int, y:int) -&gt; int&gt;&gt;&gt; add.__annotations__&#123;'x': &lt;class 'int'&gt;, 'y': &lt;class 'int'&gt;, 'return': &lt;class 'int'&gt;&#125; 定义有默认参数的函数定义一个有可选参数的函数，直接在函数定义中给参数一个默认值，并放到参数列表最后。 123456&gt;&gt;&gt; def spam(a, b=42): print(a, b)&gt;&gt;&gt; spam(1)1 42&gt;&gt;&gt; spam(1, 2)1 2 如果默认参数是一个可修改的容器，比如一个列表、集合或字典，可以使用None作为默认值。默认参数值应该是不可变对象，比如None、True、False、数字或者字符串。 默认参数的值仅仅在函数定义的时候被赋值一次。 12345678&gt;&gt;&gt; x = 42&gt;&gt;&gt; def spam(a, b=x): print(a, b)&gt;&gt;&gt; spam(1)1 42&gt;&gt;&gt; x = 23 #has no effect&gt;&gt;&gt; spam(2)2 42 减少可调用对象的参数个数如果需要减少某个函数的参数个数，你可以使用functools.partial()。函数允许你给一个或多个参数设置固定值，减少接下来被调用时的参数个数。 1234567891011&gt;&gt;&gt; def spam(a, b, c, d): print(a, b, c, d)&gt;&gt;&gt; from functools import partial&gt;&gt;&gt; s1 = partial(spam, 1)&gt;&gt;&gt; s1(2, 3, 4)1 2 3 4&gt;&gt;&gt; s1(4, 5, 6)1 4 5 6&gt;&gt;&gt; s2 = partial(spam, d=42)&gt;&gt;&gt; s2(1, 2, 3)1 2 3 42 12345678910&gt;&gt;&gt; points = [(1, 2), (3, 4), (5, 6), (7, 8 )]&gt;&gt;&gt; import math&gt;&gt;&gt; def distance(p1, p2): #计算两点间距离 x1, y1 = p1 x2, y2 = p2 return math.hypot(x2-x1, y2-y1)&gt;&gt;&gt; pt = (4, 3)&gt;&gt;&gt; points.sort(key=partial(distance, pt)) #key只接受一个单参数的函数，使用partial来兼容&gt;&gt;&gt; points[(3, 4), (1, 2), (5, 6), (7, 8)]","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python之数据结构","slug":"Python之数据结构","date":"2019-05-24T07:47:05.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/05/24/Python之数据结构/","link":"","permalink":"https://afulla.github.io/2019/05/24/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"内置序列类型容器序列 list tuple collections.deque这些序列能存放不同类型的数据。 扁平序列 str bytes bytearray memoryview array.array这类序列只能容纳一种类型。 容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用（一段连续的内存空间）。 序列类型还可按能否被修改来分类。 可变序列 list bytearray array.array collections.deque memoryview 不可变序列 tuple str bytes","text":"内置序列类型容器序列 list tuple collections.deque这些序列能存放不同类型的数据。 扁平序列 str bytes bytearray memoryview array.array这类序列只能容纳一种类型。 容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用（一段连续的内存空间）。 序列类型还可按能否被修改来分类。 可变序列 list bytearray array.array collections.deque memoryview 不可变序列 tuple str bytes 列表推导和生成器表达式虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵循了迭代器的协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里，可节省内存。 序列增量操作对不可变序列进行重复的拼接操作的话，效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素先复制到新对象里，然后再追加新的元素。str是一个例外，为str初始化内存的时候，程序会为它留出额外的可扩展空间。增量赋值不是一个原子操作。 对可变对象来说，+=运算符就地修改列表。对不可变对象，如元组，+=运算符会创建一个新对象。 可散列的数据类型如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现__hash__()方法，另外可散列对象还要有__eq__()方法，这样才能跟其他键作比较，如果两个可散列对象是相等的，那么它们的散列值（id()函数的返回值）一定是一样的。原子不可变数据类型（str、bytes和数值类型）都是可散列类型。 不要使用可变类型作为参数的默认值。 元组的相对不可变性元组与多数Python集合（列表、字典、集合等等）一样，保存的是对象的引用。如果引用的元素是可变的，即便元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变。元组的值会随着引用的可变对象的变化而变，元组中不可变的是元素的标识。 垃圾回收与引用del语句删除名称，而不是对象。在CPython中，垃圾回收使用的算法主要是引用计数。实际上，每个对象都会统计有多少引用指向自己，当引用计数归零时，对象立即就被销毁（CPython会在对象上调用__del__方法，然后释放分配给对象的内存）。 正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。但弱引用不会增加对象的引用数量。 get、setdefault、collections.defaultdictdict.get(key, default=None) 返回给定键的值，如果键不存在，则返回默认值（没有改变字典） dict.setdefault(key, default=None) 返回给定键的值，如果键不存在，则返回该键设置的值（改变了字典） collections.defaultdict([default_factory[, ...]]) 属于collections模块下的一个工厂函数，用于构建字典对象，使用default_factory给所有key对应的value赋初始值。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://afulla.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Python之魔法方法","slug":"Python之魔法方法","date":"2019-05-23T08:57:05.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/05/23/Python之魔法方法/","link":"","permalink":"https://afulla.github.io/2019/05/23/Python%E4%B9%8B%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/","excerpt":"12&gt;&gt;&gt; import collections&gt;&gt;&gt; Card = collections.namedtuple('Card', ['rank', 'suit']) namedtuple用以构建只有少数属性但是没有方法的对象 123456789class FrenchDeck: ranks = [str(n) for n in range(2,11)] + list('JQKA') suits = ['spades', 'diamonds', 'clubs', 'hearts'] def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self,position): return self._cards[position] 123456789101112131415161718&gt;&gt;&gt; deck = FrenchDeck()&gt;&gt;&gt; len(deck)52&gt;&gt;&gt; deck[4]Card(rank='6', suit='spades')&gt;&gt;&gt; from random import choice&gt;&gt;&gt; choice(deck)Card(rank='7', suit='clubs')&gt;&gt;&gt; deck[:3][Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]&gt;&gt;&gt; deck[12::13][Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]&gt;&gt;&gt; for card in deck: print(card) Card(rank='2', suit='spades')Card(rank='3', suit='spades')Card(rank='4', suit='spades')... 这样处理，不必再去记住标准操作的各式名称（“怎么得到元素总数”是.size()还是.length()还是别的什么）。可以更加方便地利用Python的标准库。","text":"12&gt;&gt;&gt; import collections&gt;&gt;&gt; Card = collections.namedtuple('Card', ['rank', 'suit']) namedtuple用以构建只有少数属性但是没有方法的对象 123456789class FrenchDeck: ranks = [str(n) for n in range(2,11)] + list('JQKA') suits = ['spades', 'diamonds', 'clubs', 'hearts'] def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self,position): return self._cards[position] 123456789101112131415161718&gt;&gt;&gt; deck = FrenchDeck()&gt;&gt;&gt; len(deck)52&gt;&gt;&gt; deck[4]Card(rank='6', suit='spades')&gt;&gt;&gt; from random import choice&gt;&gt;&gt; choice(deck)Card(rank='7', suit='clubs')&gt;&gt;&gt; deck[:3][Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]&gt;&gt;&gt; deck[12::13][Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]&gt;&gt;&gt; for card in deck: print(card) Card(rank='2', suit='spades')Card(rank='3', suit='spades')Card(rank='4', suit='spades')... 这样处理，不必再去记住标准操作的各式名称（“怎么得到元素总数”是.size()还是.length()还是别的什么）。可以更加方便地利用Python的标准库。 特殊方法的存在是为了被Python解释器调用的，在执行len(my_object)的时候，如果my_object是一个自定义类，那么Python会自己去调用其中由你实现的__len__方法，如果是内置类型（list、str等），那么CPython会抄个近路，__len__实际上会直接返回PyVarObject（表示内存中长度可变的内置对象的C语言结构体）里的ob_size属性，直接读取这个值比调用一个方法要快很多。for i in x:这个语句，背后其实调用的是iter(x)，而这个函数背后则是x.__iter__()方法。","categories":[],"tags":[{"name":"基础记录","slug":"基础记录","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95/"},{"name":"数据模型","slug":"数据模型","permalink":"https://afulla.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"}]},{"title":"Python基础记录(8)","slug":"Python基础记录-8","date":"2019-05-10T03:55:05.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/05/10/Python基础记录-8/","link":"","permalink":"https://afulla.github.io/2019/05/10/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-8/","excerpt":"","text":"最简单的服务器 1234567891011import sockets = socket.socket()host = socket.gethostname() //获取当前机器的主机名port = 1234s.bind((host, port))s.listen(5) //最多5个连接在队列中等待接纳，到达这个数量后将开始拒绝连接while True: c, addr = s.accept() //接受客户端连接，c为客户端套接字 print('Got connection from', addr) c.send('Thank you for connecting') c.close() 最简单的客户端 123456import sockets = socket.socket()host = socket.gethostname()port = 1234s.connect((host, port))print(s.recv(1024))","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"网络编程","slug":"网络编程","permalink":"https://afulla.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Python基础记录(7)","slug":"Python基础记录-7","date":"2019-05-09T09:50:09.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/05/09/Python基础记录-7/","link":"","permalink":"https://afulla.github.io/2019/05/09/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-7/","excerpt":"","text":"Python代码覆盖率检查单元测试unittest框架代码检查PyLint性能分析profile与cProfile","categories":[],"tags":[{"name":"-测试","slug":"测试","permalink":"https://afulla.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Python基础记录(6)","slug":"Python基础记录-6","date":"2019-04-23T09:17:29.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/04/23/Python基础记录-6/","link":"","permalink":"https://afulla.github.io/2019/04/23/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-6/","excerpt":"魔法方法、特性和迭代器重写构造函数 重写是继承机制的一个重要方面，对构造函数来说尤其重要。构造函数用于初始化新建对象。对大多数子类来说，除超类的初始化代码外，还需要有自己的初始化代码。重写构造函数时更有可能遇到 一个特别的问题：重写构造函数时，必须调用超类的构造函数，否则可能无法正确地初始化对象。 123456789class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print(\"Ahhh..\") self.hungry = False else: print(\"No,thanks!\") 12345&gt;&gt;&gt; b = Bird()&gt;&gt;&gt; b.eat()Ahhh..&gt;&gt;&gt; b.eat()No,thanks! 123456class SongBird(Bird): def __init__(self): super().__init__() //如果没有调用超类的构造函数，将不包含属性hungry，导致调用eat()方法时报错 self.sound = 'Squawk' def sing(self): print(self.sound) 1234567&gt;&gt;&gt; s = SongBird()&gt;&gt;&gt; s.sing()Squawk&gt;&gt;&gt; s.eat()Ahhh..&gt;&gt;&gt; s.eat()No,thanks!","text":"魔法方法、特性和迭代器重写构造函数 重写是继承机制的一个重要方面，对构造函数来说尤其重要。构造函数用于初始化新建对象。对大多数子类来说，除超类的初始化代码外，还需要有自己的初始化代码。重写构造函数时更有可能遇到 一个特别的问题：重写构造函数时，必须调用超类的构造函数，否则可能无法正确地初始化对象。 123456789class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print(\"Ahhh..\") self.hungry = False else: print(\"No,thanks!\") 12345&gt;&gt;&gt; b = Bird()&gt;&gt;&gt; b.eat()Ahhh..&gt;&gt;&gt; b.eat()No,thanks! 123456class SongBird(Bird): def __init__(self): super().__init__() //如果没有调用超类的构造函数，将不包含属性hungry，导致调用eat()方法时报错 self.sound = 'Squawk' def sing(self): print(self.sound) 1234567&gt;&gt;&gt; s = SongBird()&gt;&gt;&gt; s.sing()Squawk&gt;&gt;&gt; s.eat()Ahhh..&gt;&gt;&gt; s.eat()No,thanks! 实现了方法__iter__的对象是可迭代的，实现了方法__next__的对象是迭代器。 123456789class Fibs: def __init__(self): self.a = 0 self.b =1 def __next__(self): self.a, self.b = self.b, self.a+self.b return self.a def __iter__(self): return self 通过对可迭代对象调用内置函数iter，可获得一个迭代器。 12345&gt;&gt;&gt; it = iter([1, 2, 3, 4])&gt;&gt;&gt; next(it)1&gt;&gt;&gt; next(it)2 包含yield语句的函数都被称为生成器，生成器不是使用return返回一个值，而是可以生成多个值，每次一个。每次使用yield生成一个值后，函数都将被冻结，即在此停止执行，等待被重新唤醒。被重新唤醒后，函数将从停止的地方开始继续执行。 简单生成器（生成器推导），不同于列表推导，使用圆括号 1234&gt;&gt;&gt; [i+2 for i in range(10)][2, 3, 4, 5, 6, 7, 8, 9, 10, 11]&gt;&gt;&gt; (i+2 for i in range(10))&lt;generator object &lt;genexpr&gt; at 0x0000000002BB4938&gt;","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python基础记录(5)","slug":"Python基础记录-5","date":"2019-04-22T03:21:54.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/04/22/Python基础记录-5/","link":"","permalink":"https://afulla.github.io/2019/04/22/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-5/","excerpt":"","text":"作用域1234&gt;&gt;&gt; x = 1&gt;&gt;&gt; scope = vars()&gt;&gt;&gt; scope['x']1 全局作用域外，每个函数调用都将创建一个作用域。函数内部使用的变量称为局部变量（与之对应的是全局变量）。 globals返回一个包含全局变量的字典，locals返回一个包含局部变量的字典。 作用域嵌套应用：一个函数位于另一个函数中，而且外面的函数返回里面的函数。闭包：存储其所在作用域的函数。 面向对象设计对象：由属性和方法组成。属性是对象的变量，方法是存储在属性中的函数。与函数相比，关联方法总将其所属的对象作为第一个参数（通常为self）。 类：表示一组对象，每个对象都属于特定的类。类的主要任务是定义其实例将包含的方法。 多态：能够同样地对待不同类型的对象，即无需知道对象属于哪个类就可以调用其方法。 封装：对象可能隐藏其内部状态。在Python中，所有属性都是公有的。（要让方法或属性成为私有，名称前面加__） 继承：一个类可以是一个或多个类的子类，子类继承超类的所有方法。（内置方法issubclass，特殊属性__bases__） 抽象基类：使用模块abc可创建抽象基类。抽象基类用于指定子类必须提供哪些功能，却不实现这些功能。最重要特征是不能实例化。 12345from abc import ABC, abstractmethodClass A(ABC): @abstractmethod def foo(self): pass","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python基础记录(4)","slug":"Python基础记录-4","date":"2019-04-19T07:07:40.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/04/19/Python基础记录-4/","link":"","permalink":"https://afulla.github.io/2019/04/19/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-4/","excerpt":"","text":"模块导入注意点 推荐使用import somemodule 仅当确定要导入模块中的一切时，才采用form somemodule import *(避免命名冲突) 可在末尾添加as子句并指定别名来避免冲突 from module1 import foo as foo1 from module2 import foo as foo2","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Python基础记录(3)","slug":"Python基础记录-3","date":"2019-04-19T03:51:32.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/04/19/Python基础记录-3/","link":"","permalink":"https://afulla.github.io/2019/04/19/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-3/","excerpt":"序列操作切片技巧12345678910111213141516171819&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; numbers[7:11][8, 9, 10]&gt;&gt;&gt; numbers[-3:][8, 9, 10]&gt;&gt;&gt; numbers[0:3][1, 2, 3]&gt;&gt;&gt; numbers[:3][1, 2, 3]&gt;&gt;&gt; numbers[:-3][1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; numbers[:10:2][1, 3, 5, 7, 9]&gt;&gt;&gt; numbers[3:6:3][4]&gt;&gt;&gt; numbers[::4][1, 5, 9]&gt;&gt;&gt; numbers[8:3:-2][9, 7, 5]","text":"序列操作切片技巧12345678910111213141516171819&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; numbers[7:11][8, 9, 10]&gt;&gt;&gt; numbers[-3:][8, 9, 10]&gt;&gt;&gt; numbers[0:3][1, 2, 3]&gt;&gt;&gt; numbers[:3][1, 2, 3]&gt;&gt;&gt; numbers[:-3][1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; numbers[:10:2][1, 3, 5, 7, 9]&gt;&gt;&gt; numbers[3:6:3][4]&gt;&gt;&gt; numbers[::4][1, 5, 9]&gt;&gt;&gt; numbers[8:3:-2][9, 7, 5] 常规复制与copy常规复制只是将另一个名称关联到列表 1234567&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[1] = 4&gt;&gt;&gt; b[1, 4, 3]&gt;&gt;&gt; a[1, 4, 3] 要让a、b指向不同的列表，必须将b关联到a的副本 1234567&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b= a.copy()&gt;&gt;&gt; b[1] = 4&gt;&gt;&gt; b[1, 4, 3]&gt;&gt;&gt; a[1, 2, 3] 列表的extend和+拼接常规拼接返回全新列表，extend修改被扩展的序列 12345678910111213&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [4, 5, 6]&gt;&gt;&gt; a+b[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b[4, 5, 6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; b[4, 5, 6] 堆位置 i 处的元素总是大于位置 i//2处的元素，此为堆特征。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://afulla.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Python基础记录(2)","slug":"Python基础记录-2","date":"2019-04-18T09:36:51.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/04/18/Python基础记录-2/","link":"","permalink":"https://afulla.github.io/2019/04/18/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-2/","excerpt":"","text":"ASCII，Unicode和UTF-8”字符“的最佳定义是Unicode字符。从Python3的str对象中获取的元素是Unicode字符。 字符的标识，即码位，是01114111的数字（十进制），在Unicode标准中以46个十六进制数字表示，而且加前缀“U+”。字符的具体表述取决于所用的编码（在码位和字节序列之间转换时使用的算法）。把码位转换成字节序列的过程是编码，把字节序列转换成码位的过程是解码。 ASCII码 内存和磁盘中，对象都是以二进制数字（0和1）表示的（这些数字每8个为一组，即一个字节byte），一个字节一共可以用来表示256种不同状态。ASCII码一共规定了128个字符编码。Python bytes字面量只支持ASCII标准中的128个字符，剩余的必须用转义序列表示，例如，\\xf0表示十六进制值0xf0。 Unocode解决传统字符编码方案的局限性，为每种语言中的每个字符设定统一且唯一的二进制代码，以满足跨语言、跨平台进行文本转换处理的需求。Unicode只是个符号集，规定了符号的二进制代码，却没规定这个二进制代码应该如何存储，会存在字节顺序的问题（怎么知道两个字节表示一个符号，而不是两个符号呢），也会存在空间浪费的问题（英文字母仅需一个字节，若规定两个字节表示，那么必有一字节是0） UTF-8 如果主要处理的是互联网常见语言书写的文本，那么使用变长编码（对于不同字符，使用不同数量的字节进行编码）UTF-8即可。UTF-8编码解读：如果第一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 Python3默认编码方式为UTF-8(Unicode实现方式之一) 123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'utf-8' 123&gt;&gt;&gt; name1 = '小美'&gt;&gt;&gt; type(name1)&lt;class 'str'&gt; str转换成bytes 12345&gt;&gt;&gt; name2 = name1.encode('utf-8')&gt;&gt;&gt; name2b'\\xe5\\xb0\\x8f\\xe7\\xbe\\x8e'&gt;&gt;&gt; type(name2)&lt;class 'bytes'&gt; bytes转换成str 12345&gt;&gt;&gt; name3 = name2.decode('utf-8')&gt;&gt;&gt; name3'小美'&gt;&gt;&gt; type(name3)&lt;class 'str'&gt;","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编码","slug":"编码","permalink":"https://afulla.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"Python基础记录(1)","slug":"Python基础记录-1","date":"2019-04-17T09:30:20.000Z","updated":"2020-10-13T10:22:00.000Z","comments":true,"path":"2019/04/17/Python基础记录-1/","link":"","permalink":"https://afulla.github.io/2019/04/17/Python%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95-1/","excerpt":"","text":"除法运算的结果为浮点数 1234&gt;&gt;&gt; 1/20.5&gt;&gt;&gt; 1/11.0 如果想要返回整型结果，使用整除运算（//) 1234&gt;&gt;&gt; 1//20&gt;&gt;&gt; 1//11 整除运算结果是向下圆整的 1234&gt;&gt;&gt; 10//33&gt;&gt;&gt; -10//3-4 input(…)是以文本或字符串的形式返回 1234&gt;&gt;&gt; number = input(\"Ener a number: \")Ener a number: 5&gt;&gt;&gt; number'5'","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}],"categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://afulla.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Selenium","slug":"Selenium","permalink":"https://afulla.github.io/tags/Selenium/"},{"name":"数据结构","slug":"数据结构","permalink":"https://afulla.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"日常记录","slug":"日常记录","permalink":"https://afulla.github.io/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"属性","slug":"属性","permalink":"https://afulla.github.io/tags/%E5%B1%9E%E6%80%A7/"},{"name":"描述符","slug":"描述符","permalink":"https://afulla.github.io/tags/%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"name":"基础知识","slug":"基础知识","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"协程","slug":"协程","permalink":"https://afulla.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://afulla.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://afulla.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"Appium","slug":"Appium","permalink":"https://afulla.github.io/tags/Appium/"},{"name":"生成器","slug":"生成器","permalink":"https://afulla.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"https://afulla.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://afulla.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"弱引用","slug":"弱引用","permalink":"https://afulla.github.io/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"},{"name":"基础记录","slug":"基础记录","permalink":"https://afulla.github.io/tags/%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95/"},{"name":"数据模型","slug":"数据模型","permalink":"https://afulla.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"},{"name":"网络编程","slug":"网络编程","permalink":"https://afulla.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"-测试","slug":"测试","permalink":"https://afulla.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"编码","slug":"编码","permalink":"https://afulla.github.io/tags/%E7%BC%96%E7%A0%81/"}]}